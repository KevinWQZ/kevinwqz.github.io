<!DOCTYPE html>
<html>

  
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="baidu-site-verification" content="vuqzu4486i" />
  <meta name="baidu-site-verification" content="yR54QJzaFG" />
  <title>iOS 单元测试和 UI 测试快速入门</title>
  <meta name="description" content="">
  <meta name="author" content="xie tao">

<!--   <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="iOS 单元测试和 UI 测试快速入门">
  <meta name="twitter:description" content=""> -->
  
<!--   <meta property="og:type" content="article">
  <meta property="og:title" content="iOS 单元测试和 UI 测试快速入门">
  <meta property="og:description" content=""> -->
  
  <link rel="icon" type="image/png" href="/assets/images/favicon.ico" />
  <link href="/assets/images/favicon.ico" rel="shortcut icon" type="image/png">
  
  <link rel="stylesheet" href="/css/main.css">
  <link href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">

  <link rel="canonical" href="http://localhost:4000/2018/12/TestingTutorial/">
  <link rel="alternate" type="application/rss+xml" title="wangquanzhen" href="http://localhost:4000/feed.xml">
  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">

  <meta name="google-site-verification" content="1-1ZlHoRvM0T2FqPbW2S-qLgYXN6rsn52kErlMPd_gw" />

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?df0994aacf7a4c9779a5632908de3196";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

  
</head>


  <body>

    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>
    
    <header class="panel-cover panel-cover--collapsed" style="background-image: url('/assets/images/background-cover.jpg')">
  <div class="panel-main">

    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/#blog" title="前往 wangquanzhen 的主页" class="blog-button"><img src="/assets/images/avatar.jpg" width="80" alt="wangquanzhen logo" class="panel-cover__logo logo" /></a>
        <h1 class="panel-cover__title panel-title"><a href="/#blog" title="前往 wangquanzhen 的主页" class="blog-button">wangquanzhen</a></h1>
        
        <span class="panel-cover__subtitle panel-subtitle">探索之旅，学习之路</span>
        
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description">你好，我是王权振！欢迎来到我的个人主页.</br>90后代码搬运工，</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />
        
        
        
        <div class="navigation-wrapper">
          <div>
            <nav class="cover-navigation cover-navigation--primary">
              <ul class="navigation">
                <li class="navigation__item"><a href="/#blog" title="进入博客" class="blog-button">博客</a></li>
                
                  <li class="navigation__item"><a href="/about/index.html" target="_blank" title="了解更多关于我">关于</a></li>
                
              </ul>
            </nav>
          </div>
          
          <div><nav class="cover-navigation navigation--social">
  <ul class="navigation">

  
  <!-- Weibo -->
  <li class="navigation__item">
  
    <a href="http://weibo.com/u/2803559240" title="xietao3 的微博" target="_blank">
    <!-- <a href="http://weibo.com/xietao3" title="xietao3 的微博" target="_blank"> -->
      <i class='social fa fa-weibo'></i>
      <span class="label">Weibo</span>
    </a>
  </li>
  

  
  <!-- Github -->
  <li class="navigation__item">
    <a href="https://github.com/xietao3" title="xietao3 的 Github" target="_blank">
      <i class='social fa fa-github'></i>
      <span class="label">Github</span>
    </a>
  </li>
  
  
  

  

  
   <!-- CSDN -->
  <li class="navigation__item">
    <a href="http://blog.csdn.net/xietao3" title="xietao3 的 CSDN" target="_blank">
      <img src="/assets/images/csdn.png" width="20" height="20" />
      <!-- <i class='social fa fa-edit'></i> -->
      <span class="label">csdn</span>
    </a>
  </li>
  

  <!-- RSS -->
<!--   <li class="navigation__item">
    <a href="/feed.xml" rel="author" title="RSS" target="_blank">
      <i class='social fa fa-rss'></i>
      <span class="label">RSS</span>
    </a>
  </li> -->

  

  </ul>
</nav>
</div>
        </div>
      </div>
    </div>
    
    
    <div class="panel-cover--overlay cover-orange"></div>
    
  </div>
</header>


    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    <div class="post-meta">
      <time datetime="2018-12-20 10:40:11 +0800" itemprop="datePublished" class="post-meta__date date">2018-12-20</time> &#8226; <span class="post-meta__tags tags"></span>
    </div>
    <h1 class="post-title">iOS 单元测试和 UI 测试快速入门</h1>
  </header>

  <section class="post">
    <p><img src="https://raw.githubusercontent.com/xietao3/Study-Plan/master/TestingTutorial/src/preview.png" alt="" /></p>

<h2 id="前言">前言</h2>

<p>平时写完业务代码的时候都会去自己测试一遍，后面每次有修改都需要重复测，不管是一个业务流程还是一个工具类，其实都可以通过测试框架来帮助我们完成测试，特别是一些频繁修改的代码，更需要严谨的测试。在浅浅地对自动化测试有一些了解时，觉得写测试代码挺耗时间，但其实对后期的帮助是非常大的，可以根据自己的实际情况来决定哪些地方需要加入自动化测试。</p>

<p>本文内容适合刚接触 iOS 自动化测试的同学，基本内容来自于各年 WWDC 的多个 Sessions，本文代码部分基于我的一个学习 <a href="https://github.com/xietao3/Study-Plan/tree/master/TestingTutorial/demo/">Demo</a>，喜欢的可以了解一下。本文介绍的大致内容包括：</p>

<ul>
  <li><strong>单元测试</strong></li>
  <li><strong>UI 测试</strong></li>
  <li><strong>拓展 Tips</strong></li>
  <li><strong>工程可测性</strong></li>
</ul>

<h2 id="一单元测试">一、单元测试</h2>

<h3 id="11-加入测试-target">1.1 加入测试 Target</h3>

<p>在新建项目时，勾选<code class="highlighter-rouge">Include Unit Tests</code>和<code class="highlighter-rouge">Include UI Tests</code>,即可为项目添加单元测试和 UI 测试。</p>

<p>在添加测试代码时，你需要遵守一些最基本的规则：</p>

<ul>
  <li>
    <p>所有的测试类需要继承<code class="highlighter-rouge">XCTestCase</code></p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  @interface TTTestCase : XCTestCase
</code></pre></div>    </div>
  </li>
  <li>
    <p>测试方法命名以 test 开始</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  - (void)testThatMyFunctionWorks
</code></pre></div>    </div>
  </li>
  <li>
    <p>用 Assertion API 进行验证是否通过</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  XCTAssertEqual(value, expectedValue)
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="12-启动测试">1.2 启动测试</h3>

<p>单元测试的结构：</p>

<ul>
  <li>step1：准备输入</li>
  <li>step2：运行正在测试的代码</li>
  <li>step3：验证输出</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 准备输入
NSString *dateString = @"2000-01-01";

// 需要测试的方法
BOOL isToday = [TTDateFormatter isTodayWithDateString:dateString];

// 验证输出
XCTAssert(isToday, @"isToday false");
</code></pre></div></div>

<p>以上三个部分的代码准备完成后即可开始测试，启动的方式有很多种，可以根据你的实际情况选择以下方式：</p>

<ul>
  <li>代码编辑器边栏菱形按钮，测试单个用例</li>
  <li>Test 导航栏，测试单个用例</li>
  <li>快捷键<code class="highlighter-rouge">⌘ + U</code>测试全部用例</li>
  <li>使用命令行工具 xcodebuild 可以测试单个用例，也可以测试全部用例。</li>
</ul>

<p><img src="https://raw.githubusercontent.com/xietao3/Study-Plan/master/TestingTutorial/src/1.1.png" alt="123" /></p>

<h3 id="13-性能测试">1.3 性能测试</h3>

<p>性能测试通过度量代码块执行所消耗的时间长短，来衡量是否通过测试。</p>

<h4 id="131-如何进行性能测试">1.3.1 如何进行性能测试</h4>

<p>相关 API :</p>

<ul>
  <li>
    <p>measureBlock:</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  - (void)testPerformanceOfMyFunction {

      [self measureBlock:^{
          // Do that thing you want to measure.
          MyFunction();
      }];
  }
</code></pre></div>    </div>
  </li>
  <li>
    <p>measureMetrics:automaticallyStartMeasuring:forBlock:</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  - (void)testMyFunction2_WallClockTime {
      [self measureMetrics:[self class].defaultPerformanceMetrics automaticallyStartMeasuring:NO forBlock:^{

          // Do setup work that needs to be done for every iteration but you don't want to measure before the call to -startMeasuring
          SetupSomething();
          [self startMeasuring];

          // Do that thing you want to measure.
          MyFunction();
          [self stopMeasuring];

          // Do teardown work that needs to be done for every iteration but you don't want to measure after the call to -stopMeasuring
          TeardownSomething();
      }];
  }
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="132-设置基准线">1.3.2 设置基准线</h4>

<p>所有的性能测试需要设置一个<code class="highlighter-rouge">Baseline</code>来验证是否通过测试，没有设置的会提示<code class="highlighter-rouge">No baseline average for Time</code>。</p>

<p><img src="https://raw.githubusercontent.com/xietao3/Study-Plan/master/TestingTutorial/src/1.2.png" alt="1.2" /></p>

<p>我们可以通过点击<code class="highlighter-rouge">measureBlock:</code>方法左边菱形圆心 icon ，来设置<code class="highlighter-rouge">Baseline</code>,设置之后需要点击<code class="highlighter-rouge">save</code>保存。之后再执行测试用例时，如果成功，左边的icon会从圆心变成一个 ✅。</p>

<p><img src="https://raw.githubusercontent.com/xietao3/Study-Plan/master/TestingTutorial/src/1.3.png" alt="1.2" /></p>

<h3 id="14-异步测试">1.4 异步测试</h3>

<p>什么时候需要使用异步测试：</p>

<ul>
  <li>打开文档</li>
  <li>在后台线程中执行的服务和网络活动</li>
  <li>执行动画</li>
  <li>UI 测试时</li>
</ul>

<h4 id="141-异步测试-xctestexpectation">1.4.1 异步测试 XCTestExpectation</h4>

<p>异步测试分为3个部分： <strong>新建期望</strong> 、 <strong>等待期望被履行</strong> 和 <strong>履行期望</strong> 。</p>

<ul>
  <li>
    <p>XCTestExpectation ：测试期望，可以由测试类持有，也可以自己持有，自己持有测试期望时灵活性更好一些，你可以选择等待哪些期望。</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  // 测试类持有的初始化方法
  XCTestExpectation *expect1 = [self expectationWithDescription:@"asyncTest1"];
	
  // 自己持有的初始化方法
  XCTestExpectation *expect2 = [[XCTestExpectation alloc] initWithDescription:@"asyncTest3"];
</code></pre></div>    </div>
  </li>
  <li>
    <p>waitForExpectations:timeout: ：等待异步的期望代码执行，根据初始化方式不同，等待的方法不同。</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  // 测试类持有时的等待方法
  [self waitForExpectationsWithTimeout:10.0 handler:nil];
	
  // 自己持有时的等待方法
  [self waitForExpectations:@[expect3] timeout:10.0];
</code></pre></div>    </div>
  </li>
  <li>
    <p>fulfill ：履行期望，并且适当加入<code class="highlighter-rouge">XCTAssertTrue</code>等断言，来验证测试结果。</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  XCTestExpectation *expect3 = [[XCTestExpectation alloc] initWithDescription:@"asyncTest3"];
    
  [TTFakeNetworkingInstance requestWithService:apiRecordList completionHandler:^(NSDictionary *response) {
      XCTAssertTrue([response[@"code"] isEqualToString:@"200"]);
      [expect3 fulfill];
  }];
    
  [self waitForExpectations:@[expect3] timeout:10.0];
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="142-异步测试-xctwaiter">1.4.2 异步测试 XCTWaiter</h4>

<p><code class="highlighter-rouge">XCTWaiter</code>是 2017 年新增的异步测试方案，可以通过代理方式来处理异常情况。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>XCTWaiter *waiter = [[XCTWaiter alloc] initWithDelegate:self];
    
XCTestExpectation *expect4 = [[XCTestExpectation alloc] initWithDescription:@"asyncTest3"];
    
[TTFakeNetworkingInstance requestWithService:@"product.list" completionHandler:^(NSDictionary *response) {
	XCTAssertTrue([response[@"code"] isEqualToString:@"200"]);
	expect4 fulfill];
}];

XCTWaiterResult result = [waiter waitForExpectations:@[expect4] timeout:10 enforceOrder:NO];

XCTAssert(result == XCTWaiterResultCompleted, @"failure: %ld", result);
</code></pre></div></div>

<p>XCTWaiterDelegate：如果委托是<code class="highlighter-rouge">XCTestCase</code>实例，下方代理被调用时会报告为测试失败。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 如果有期望超时，则调用。 
- (void)waiter:(XCTWaiter *)waiter didTimeoutWithUnfulfilledExpectations:(NSArray&lt;XCTestExpectation *&gt; *)unfulfilledExpectations;

// 当履行的期望被强制要求按顺序履行，但期望以错误的顺序被履行，则调用。
- (void)waiter:(XCTWaiter *)waiter fulfillmentDidViolateOrderingConstraintsForExpectation:(XCTestExpectation *)expectation requiredExpectation:(XCTestExpectation *)requiredExpectation;

// 当某个期望被标记为被倒置，则调用。 
- (void)waiter:(XCTWaiter *)waiter didFulfillInvertedExpectation:(XCTestExpectation *)expectation;

// 当 waiter 在 fullfill 和超时之前被打断，则调用。 
- (void)nestedWaiter:(XCTWaiter *)waiter wasInterruptedByTimedOutWaiter:(XCTWaiter *)outerWaiter;
</code></pre></div></div>

<h3 id="15-查看测试结果">1.5 查看测试结果</h3>

<p>在执行测试用例后，Xcode 会返回给我们测试结果，可以通过一下途径查看：</p>

<ul>
  <li>Test 导航栏</li>
  <li>Issue 导航栏</li>
  <li>代码编辑器左边栏</li>
  <li>Report 导航栏</li>
</ul>

<p><img src="https://raw.githubusercontent.com/xietao3/Study-Plan/master/TestingTutorial/src/1.4.png" alt="查看测试结果" /></p>

<p>除此之外，我们还可以在 Report 导航栏中查看更加详细的测试报告:</p>

<ul>
  <li>测试通过/失败</li>
  <li>失败原因</li>
  <li>性能指标</li>
  <li>截屏</li>
  <li>嵌套的 activities</li>
  <li>测试覆盖率</li>
</ul>

<p><img src="https://raw.githubusercontent.com/xietao3/Study-Plan/master/TestingTutorial/src/1.5.png" alt="" /></p>

<h3 id="16-进行单元测试">1.6 进行单元测试</h3>

<p>我新建一个时间工具类，帮助我转换时间，在使用之前，我们需要先进行测试，以保证功能完整且正确。</p>

<p>这个工具类有以下 4 个公共方法，</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@interface TTDateFormatter : NSDate

+ (NSString *)stringFormatWithDate:(NSDate *)date;

+ (NSDate *)dateFormatWithString:(NSString *)dateString;

+ (BOOL)isTodayWithDateString:(NSString *)dateString;

+ (NSString *)getHowLongAgoWithTimeStamp:(NSTimeInterval)timeStamp;

@end
</code></pre></div></div>

<p>针对一个工具类的测试我们可以新建一个<code class="highlighter-rouge">TTDateFormatterTests</code>测试类，继承一个测试基类。再根据不同的方法写不同的测试方法。如果有<code class="highlighter-rouge">if</code>和<code class="highlighter-rouge">switch</code>等条件语句导致逻辑分支的代码，尽量使各个逻辑分支都能测试到，可以配合代码覆盖率来检查哪些逻辑分支未测试。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@interface TTDateFormatterTests : TTTestCase
@end

@implementation TTDateFormatterTests

- (void)testDateFormatter {
    NSString *originDateString = @"2018-06-06 20:20:20";
    NSDate *date = [TTDateFormatter dateFormatWithString:originDateString];
    NSString *dateString = [TTDateFormatter stringFormatWithDate:date];
    XCTAssertEqualObjects(dateString, originDateString);
}

- (void)testDateFormatterIsToday {
    NSString *dateString = [TTDateFormatter stringFormatWithDate:[NSDate date]];
    XCTAssertTrue([TTDateFormatter isTodayWithDateString:dateString]);
    XCTAssertFalse([TTDateFormatter isTodayWithDateString:@"2000-01-01"]);
}

- (void)testDateFormatterHowLongAgo {
	// 该方法中包含一个 switch ，要保证 switch 每个逻辑分支都测试到，所以需要多个测试。
    NSDate *now = [NSDate date];
    NSString *secAgo = [TTDateFormatter getHowLongAgoWithTimeStamp:now.timeIntervalSince1970 - 10 * sec];
    XCTAssertEqualObjects(secAgo, @"10秒前");
    
    NSString *minAgo = [TTDateFormatter getHowLongAgoWithTimeStamp:now.timeIntervalSince1970 - 15 * min];
    XCTAssertEqualObjects(minAgo, @"15分钟前");
    
    NSString *hourAgo = [TTDateFormatter getHowLongAgoWithTimeStamp:now.timeIntervalSince1970 - 20 * hour];
    XCTAssertEqualObjects(hourAgo, @"20小时前");

    NSString *dayAgo = [TTDateFormatter getHowLongAgoWithTimeStamp:now.timeIntervalSince1970 - 25 * hour];
    XCTAssertEqualObjects(dayAgo, @"1天前");

    NSString *daysAgo = [TTDateFormatter getHowLongAgoWithTimeStamp:now.timeIntervalSince1970 - 50 * hour];
    XCTAssertEqualObjects(daysAgo, @"2天前");

    NSString *longTimeAgo = [TTDateFormatter getHowLongAgoWithTimeStamp:1544002463];
    XCTAssertEqualObjects(longTimeAgo, @"2018-12-05 17:34:23");
}
@end
</code></pre></div></div>

<p>合理使用测试基类和测试工具类，可以避免大量重复测试代码。时间转换工具类是一个没有外部依赖的类，当一些对外部有依赖的类需要测试时，可以尝试 <a href="https://github.com/erikdoe/ocmock">OCMock</a> ，它能帮助你模拟数据。另外，当你觉得测试框架提供的断言方法无法满足你时，也可以试着使用 <a href="https://github.com/hamcrest/OCHamcrest">OCHamcrest</a> 。</p>

<h2 id="二ui-测试">二、UI 测试</h2>

<p>什么时候需要使用 UI 测试：</p>

<ul>
  <li>单元测试无法覆盖时的补充方案</li>
  <li>单元测试更精准</li>
  <li>UI 测试覆盖面的更全</li>
</ul>

<p>UI 测试的步骤：</p>

<ul>
  <li>step1：与要测试或与逻辑有关的 UI 进行互动</li>
  <li>step2：验证 UIelements 属性和状态</li>
</ul>

<h3 id="21-ui-recording">2.1 UI Recording</h3>

<p>通过 UI Recording ，可以将你操作手机的行为记录下来，并且转换成代码，可以帮助你快速生成 UI 测试代码。</p>

<p>选中 UI 测试类，你能再下方看到一个小红点，点击小红点开始录制你的交互。</p>

<p><img src="https://raw.githubusercontent.com/xietao3/Study-Plan/master/TestingTutorial/src/2.1.png" alt="" /></p>

<p>在你进行交互时，Xcode 会自动转化成代码，你可以借此创建新的测试代码，也可以以此拓展已经存在的测试代码。当然它也不是十分完美，并不是总能如你所愿，还需要你做一些处理，比如说自动生成的代码过于繁琐，你可以用一些更简洁的代码实现。即使这样，UI Recording 也是非常高效的方式。</p>

<h3 id="22-ui-测试相关的类">2.2 UI 测试相关的类</h3>

<h4 id="221-xcuiapplication">2.2.1 XCUIApplication</h4>

<p><code class="highlighter-rouge">XCUIApplication</code>可以返回一个应用程序实例，然后你就可以通过测试代码启动应用程序。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 返回 UI 测试 Target 设置中选中的 Target Application 的实例
- (instancetype)init;

// 根据 bundleId 返回一个应用程序实例
- (instancetype)initWithBundleIdentifier:(NSString *)bundleIdentifier;

// 启动应用程序
- (void)launch;

// 将应用程序唤醒至前台，在多程序联合测试下会用到 
- (void)activate;

// 结束一个正在运行的应用程序
- (void)terminate;
</code></pre></div></div>

<h4 id="222-xcuielement">2.2.2 XCUIElement</h4>

<p>应用程序中的 UI 控件，控件类型多样，可能是<code class="highlighter-rouge">Button</code>,<code class="highlighter-rouge">Cell</code>,<code class="highlighter-rouge">Window</code>等等。该类实例有很多模拟交互的方法，如<code class="highlighter-rouge">tap</code>模拟用户点击事件，<code class="highlighter-rouge">swipe</code>模拟滑动事件，<code class="highlighter-rouge">typeText:</code>模拟用户输入内容。</p>

<p>在 UI 测试中我们需要找到某个空间，可以通过他们的类型来缩小范围，比如当前页面有且只有一个<code class="highlighter-rouge">UITextView</code>控件，你可以通过以下代码来获取：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>XCUIApplication *app = [[XCUIApplication alloc] init];
[app launch];

// 如果是 Cell 则对应 app.cells 
// firstMatch 返回第一个符合的控件
XCUIElement *textView = app.textViews.firstMatch;

// 模拟用户在 textView 输入内容
[textView typeText:@"input string"];
</code></pre></div></div>

<p>另外还有一种方式通过 Accessibility identifer， label， title 等等方式来定位对应的控件，如寻找一个名为 Add 的<code class="highlighter-rouge">button</code>。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 需要勾选 Accessibility Enabled ，并且在 Label 一栏填入 Add
XCUIElement *addButton = app.buttons[@"add"];
// 模拟用户点击按钮
[addButton tap];
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/xietao3/Study-Plan/master/TestingTutorial/src/2.2.png" alt="" /></p>

<p>通过类型加 identifier 的方式来定位的控件元素的方式，可以满足大多数场景。</p>

<h4 id="223-xcuielementquery">2.2.3 XCUIElementQuery</h4>

<p><code class="highlighter-rouge">XCUIElementQuery</code>是一个用来定位控件元素的类，一般是一组符合筛选条件的元素集合。如<code class="highlighter-rouge">app.buttons</code>即返回 XCUIElementQuery 实例，是包含了当前所有的<code class="highlighter-rouge">button</code>的集合，你可以再通过 <code class="highlighter-rouge">XCUIElementQuery</code>的方法做下一步的筛选。</p>

<p>XCUIElementQuery 常见定位元素的方法：</p>

<ul>
  <li>
    <p>count：匹配的数量;</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  // 当 navigationBars 的 count 等于 1 时，你可以直接定位到 navigationBar
  app.navigationBars.element 
</code></pre></div>    </div>
  </li>
  <li>
    <p>subscripting：通过 id 来定位</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  table.staticTexts["Groceries"] 
</code></pre></div>    </div>
  </li>
  <li>
    <p>index：通过元素的下标来定位</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  table.staticTexts.elementAtIndex(0) 
</code></pre></div>    </div>
  </li>
</ul>

<p>定位元素除了利用元素类型、Accessibility Identifiers，Predicates 等筛选方法，还可以结合嵌套的层级关系来帮助定位。</p>

<h3 id="23-进行-ui-测试">2.3 进行 UI 测试</h3>

<p>要进行 UI 测试需要以下几个步骤：</p>

<ul>
  <li>step1：新建一个 UI 测试 Target。</li>
  <li>step2：使用 UI Recording 或手写代码，定位 UI 元素，并且模拟用户交互事件。</li>
  <li>step3：加入<code class="highlighter-rouge">XCTAssert</code>等断言逻辑，验证测试是否通过。</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let app = XCUIApplication()
// 启动 app
app.launch()

// 定位元素
let addButton = app.buttons[“Add”]

// 模拟用户交互事件
addButton.tap()

// 验证测试是否通过
XCTTAssertionEqual(app.tables.cells.cout, 1)
</code></pre></div></div>

<p>大多数 UI 测试都是基于用户行为驱动，根据设计好的用户的操作流程，测试整个流程的结果。我设计了一个简单的笔记，主要有 3 步操作，分别是创建笔记、展示笔记和删除笔记，下面一起来看看如何进行测试。</p>

<p><img src="https://raw.githubusercontent.com/xietao3/Study-Plan/master/TestingTutorial/src/2.3.png" alt="" /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 测试主流程
- (void)testMainFlow {
	// 启动 app
    XCUIApplication *app = [[XCUIApplication alloc] init];
    [app launch];
    
    // 添加笔记
    [self addRecordWithApp:app msg:@"今天天气真好！🌞"];
    [self addRecordWithApp:app msg:@"今天詹姆斯特别给力，带领球队走向胜利。✌️"];
	
    while (app.cells.count &gt; 0) {
    	  // 删除笔记  
        [self deleteFirstRecordWithApp:app];
    }
}

/**
 添加笔记

 @param app app 实例
 @param msg 笔记内容
 */
- (void)addRecordWithApp:(XCUIApplication *)app msg:(NSString *)msg {
	// 暂存当前 cell 数量
    NSInteger cellsCount = app.cells.count;
    
    // 设置一个预期 判断 app.cells 的 count 属性会等于 cellsCount+1， 等待直至失败，如果符合则不再等待
    NSPredicate *predicate = [NSPredicate predicateWithFormat:@"count == %d",cellsCount+1];
    [self expectationForPredicate:predicate evaluatedWithObject:app.cells handler:nil];


	 // 定位导航栏+号按钮，点击进入添加笔记页面 
    XCUIElement *addButton = app.navigationBars[@"Record List"].buttons[@"Add"];
    [addButton tap];
    
    // 测试 未输入任何内容点击保存
    [app.navigationBars[@"Write Anything"].buttons[@"Save"] tap];
    
    // 定位文本输入框 输入内容
    XCUIElement *textView = app.textViews.firstMatch;
    [textView typeText:msg];
    
    // 保存
    [app.navigationBars[@"Write Anything"].buttons[@"Save"] tap];
        
    // 等待预期
    [self waitShortTimeForExpectations];
}

/**
 删除最近一个笔记

 @param app app 实例
 */
- (void)deleteFirstRecordWithApp:(XCUIApplication *)app {
    NSInteger cellsCount = app.cells.count;
    
    
    NSPredicate *predicate = [NSPredicate predicateWithFormat:@"count == %d",cellsCount-1];
    // 设置一个预期 判断 app.cells 的 count 属性会等于 cellsCount-1， 等待直至失败，如果符合则不再等待
    [self expectationForPredicate:predicate evaluatedWithObject:app.cells handler:nil];

	// 定位到 cell 元素
    XCUIElement *firstCell = app.cells.firstMatch;
    
    // 左滑出现删除按钮
    [firstCell swipeLeft];
    
    // 定位删除按钮
    XCUIElement *deleteButton = [app.buttons matchingIdentifier:@"Delete"].firstMatch;
    
    // 点击删除按钮
    if (deleteButton.exists) {
        [deleteButton tap];        
    }
    
    // 等待预期
    [self waitShortTimeForExpectations];

}
</code></pre></div></div>

<p>在上面的逻辑中涉及到异步的请求，我们可以通过利用<code class="highlighter-rouge">expectationForPredicate:evaluatedWithObject:handler:</code>方法监听<code class="highlighter-rouge">app.cells</code>的<code class="highlighter-rouge">count</code>属性，当满足<code class="highlighter-rouge">NSPredicate</code>条件时，<code class="highlighter-rouge">expectation</code>相当于自动<code class="highlighter-rouge">fullfill</code>。如果一直不满足条件，会一直等待直至超时，除此之外还可以用通知和 KVO 的方式实现。</p>

<p>测试过程:</p>

<p><img src="https://raw.githubusercontent.com/xietao3/Study-Plan/master/TestingTutorial/src/2.4.gif" alt="" /></p>

<h2 id="三-拓展-tips">三、 拓展 Tips</h2>

<h3 id="31-多应用联合测试">3.1 多应用联合测试</h3>

<p>多应用联合测试时，依赖<code class="highlighter-rouge">XCUIApplication</code>类的以下 2 个方法：</p>

<ul>
  <li>initWithBundleIdentifier:</li>
  <li>activate</li>
</ul>

<p>前者可以根据 BundleId 获取其他 App 的实例，让我们可以启动其他 App。后者可以让 App 从后台切换至前台，在多应用间切换。简单实现代码如下：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 返回 UI 测试 Target 设置中选中的 Target Application 的实例
XCUIApplication *ttApp = [[XCUIApplication alloc] init];

// 使用 BundleId 获得另外一个 App 实例
XCUIApplication *anotherApp = [[XCUIApplication alloc] initWithBundleIdentifier:@"Another.App.BundleId"];

// 先启动我们的主 App
[ttApp launch];

// 做一系列测试

// 启动另一个 App
[anotherApp launch];

// 做一系列测试

// 回到我们的主 App (在 App 未启动的情况下调 activate 会让 App 启动)
[ttApp activate];
</code></pre></div></div>

<h3 id="32-逻辑复杂场景下的-activities">3.2 逻辑复杂场景下的 Activities</h3>

<p>在一些逻辑比较复杂的测试中，我们可以借助<code class="highlighter-rouge">XCTContext</code>类来帮我们把测试逻辑分割成多个小的测试模块。比如说我们有一个业务，关联多个模块，这个时候我们可以用类似下面的代码来处理：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 模块 1
[XCTContext runActivityNamed:@"step1" block:^(id&lt;XCTActivity&gt;  _Nonnull activity) {
    XCTestExpectation *expect1 = [self expectationWithDescription:@"asyncTest1"];

    [TTFakeNetworkingInstance requestWithService:apiRecordSave completionHandler:^(NSDictionary *response) {
        XCTAssertTrue([response[@"code"] isEqualToString:@"200"]);
        [expect1 fulfill];
    }];
    
}];

// 模块 2
[XCTContext runActivityNamed:@"step2" block:^(id&lt;XCTActivity&gt;  _Nonnull activity) {
    XCTestExpectation *expect2 = [self expectationWithDescription:@"asyncTest2"];

    [TTFakeNetworkingInstance requestWithService:apiRecordDelete completionHandler:^(NSDictionary *response) {
        XCTAssertTrue([response[@"code"] isEqualToString:@"200"]);
        [expect2 fulfill];
    }];
    
}];

[self waitShortTimeForExpectations];
</code></pre></div></div>

<p>如果测试成功，可以在 Report 导航栏看到成功信息，它会按照你设置的模块分别展示测试结果。</p>

<p><img src="https://raw.githubusercontent.com/xietao3/Study-Plan/master/TestingTutorial/src/3.1.png" alt="" /></p>

<p>如果测试失败，你可以看到哪些模块是成功的，和在哪些模块中失败了。</p>

<p><img src="https://raw.githubusercontent.com/xietao3/Study-Plan/master/TestingTutorial/src/3.2.png" alt="" /></p>

<p>除此之外，你还可以尝试多层嵌套，activity 里面嵌套 activity。</p>

<h3 id="33-截屏">3.3 截屏</h3>

<p>在 UI 测试中有 2 种类型支持通过代码截屏，分别是<code class="highlighter-rouge">XCUIElement</code>和<code class="highlighter-rouge">XCUIScreen</code>。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 获取一个截屏对象
XCUIScreenshot *screenshot = [app screenshot];

// 实例化一个附件对象 并传入截屏对象
XCTAttachment *attachment = [XCTAttachment attachmentWithScreenshot:screenshot];

// 附件的存储策略 如果选择 XCTAttachmentLifetimeDeleteOnSuccess 则测试成功的情况会被删除
attachment.lifetime = XCTAttachmentLifetimeKeepAlways;

// 设置一个名字 方便区分
attachment.name = @"MyScreenshot";

[self addAttachment:attachment];
</code></pre></div></div>

<p>在测试结束后，可以在 Report 导航栏中查看截图：</p>

<p><img src="https://raw.githubusercontent.com/xietao3/Study-Plan/master/TestingTutorial/src/3.3.png" alt="" /></p>

<p>除此之外 Xcode 提供了自动截图的功能，可以帮助我们在每一个交互操作之后自动截图。此功能会产生大量截图，需要谨慎使用，一般情况最好勾选<code class="highlighter-rouge">Delete when each test succeeds</code>，需要在 Edit Scheme -&gt; Test -&gt; Options 中开启。</p>

<p><img src="https://raw.githubusercontent.com/xietao3/Study-Plan/master/TestingTutorial/src/3.4.png" alt="" /></p>

<p>所以你可以根据你的需求选择适当的截图策略。</p>

<h3 id="34-代码覆盖率">3.4 代码覆盖率</h3>

<p>代码覆盖率在 Report 导航栏中查看，它除了可以帮你统计测试用例覆盖的代码百分比，还可以帮助你发现哪些代码是没有被测试用例覆盖的，需要在 Edit Scheme -&gt; Test -&gt; Options 中开启。</p>

<p><img src="https://raw.githubusercontent.com/xietao3/Study-Plan/master/TestingTutorial/src/3.6.png" alt="" /></p>

<p>你还可以选择统计哪些 targets 的代码覆盖率，<code class="highlighter-rouge">all targets</code>表示统计项目内所有 targets 的覆盖率，<code class="highlighter-rouge">some targets</code>需要你手动添加 target ，只统计手动添加的 target 的覆盖率。</p>

<p><img src="https://raw.githubusercontent.com/xietao3/Study-Plan/master/TestingTutorial/src/3.5.png" alt="" /></p>

<p>除了在 Report 导航栏中查看代码覆盖率的方式，你还可以借助苹果提供的命令行工具<code class="highlighter-rouge">xccov</code>来生成代码覆盖率报告。值得一提的是，<code class="highlighter-rouge">xccov</code>还能输出 JSON 格式的报告。</p>

<h3 id="35-跳过部分测试">3.5 跳过部分测试</h3>

<p>在 Xcode 10 中新增功能，在 Edit Scheme -&gt; Test -&gt; Info -&gt; Tests 中可以通过取消勾选，来选择跳过部分测试用例。在 target 的 Options 选项中，<code class="highlighter-rouge">Automatically includes new tests</code>，选项是默认勾选的，新建的测试文件会自动添加进去。</p>

<p><img src="https://raw.githubusercontent.com/xietao3/Study-Plan/master/TestingTutorial/src/3.7.png" alt="" /></p>

<h3 id="36-测试用例的执行顺序">3.6 测试用例的执行顺序</h3>

<p>默认情况下，测试用例执行的顺序是按字母顺序来执行的，按固定顺序执行可能会使一些隐式的依赖关系无法被发现。现在有了随机的执行顺序，就可以挖掘出那些隐式的依赖关系。可以在 Edit Scheme -&gt; Test -&gt; Info -&gt; Tests -&gt; Options 中开启该功能。</p>

<p><img src="https://raw.githubusercontent.com/xietao3/Study-Plan/master/TestingTutorial/src/3.8.png" alt="" /></p>

<h3 id="37-并行测试">3.7 并行测试</h3>

<p>并行测试可以同时进行多个测试，从而节省大量时间。在测试时会启动多个模拟器，模拟器之间的数据都是隔离的，可以在 Edit Scheme -&gt; Test -&gt; Info -&gt; Tests -&gt; Options 中开启该功能。</p>

<p><img src="https://raw.githubusercontent.com/xietao3/Study-Plan/master/TestingTutorial/src/3.9.png" alt="" /></p>

<p>对于并行测试的一些建议：</p>

<ul>
  <li>某个测试用例需要消耗大量时间的类，可以拆分成多个类并行测试，从而节省时间。</li>
  <li>你需要清楚哪些测试在并行执行时是不安全的，避免并行执行这些测试。</li>
  <li>性能测试的可以统一放在一个 Bundle 中，禁用并行执行。</li>
</ul>

<h2 id="四工程可测性">四、工程可测性</h2>

<p>单元测试的结构：</p>

<ol>
  <li>准备输入</li>
  <li>运行需要测试的代码</li>
  <li>验证输出</li>
</ol>

<p>可测试代码的特征：</p>

<ul>
  <li>避免过多输入</li>
  <li>输出是可见的</li>
  <li>没有隐藏的状态</li>
</ul>

<h3 id="41-可测性-tips">4.1 可测性 Tips</h3>

<ul>
  <li>参数化：减少共享单例的引用，测试的方法需要接受参数输入和明确的输出。</li>
  <li>分离逻辑和结果：抽离逻辑，最终测试代码尽量精简。</li>
  <li>平衡单元测试和 UI 测试：单元测试适合测试用户交互行为无法覆盖的代码，和小而完整的代码。UI 测试更适合测试大范围的功能集合。</li>
</ul>

<h3 id="42-帮助-ui-测试更加完善">4.2 帮助 UI 测试更加完善</h3>

<ul>
  <li>用精巧聪明的代码缩减 UI 测试的代码量</li>
  <li>将复杂的查询逻辑进行封装</li>
  <li>对常见组合操作的 UI 测试流程进行封装</li>
  <li>避免逻辑混乱和冗余</li>
</ul>

<h4 id="43-合理使用快捷键">4.3 合理使用快捷键</h4>

<ul>
  <li>避免使用 macOS 的菜单栏</li>
  <li>使逻辑上下紧密，避免逻辑分离</li>
</ul>

<h3 id="43-测试代码的质量">4.3 测试代码的质量</h3>

<ul>
  <li>写测试代码之前多构思很重要</li>
  <li>测试代码应该支撑你的 App 的拓展</li>
  <li>业务代码中的编码原则也适用于测试代码</li>
</ul>

<p>本节内容根据 <a href="https://developer.apple.com/videos/play/wwdc2017/414/">WWDC 2017 Session 414：Engineering for Testability</a> 粗略总结得出，如果需要了解更多相关内容可以查看相关视频。</p>

<h2 id="总结">总结</h2>

<p>掌握这些测试相关 API 并不难，但是好的代码需要经过完整项目的磨砺和时间的考验。同时也可以借鉴一些开源项目的测试代码，尝试着爬上巨人的肩膀。</p>

<h2 id="参考">参考</h2>

<p><a href="https://developer.apple.com/videos/play/wwdc2018/403/">WWDC 2018 Session 403：What’s New in Testing</a></p>

<p><a href="https://developer.apple.com/videos/play/wwdc2017/414/">WWDC 2017 Session 414：Engineering for Testability</a></p>

<p><a href="https://developer.apple.com/videos/play/wwdc2017/409/">WWDC 2017 Session 409：What’s New in Testing</a></p>

<p><a href="https://developer.apple.com/videos/play/wwdc2015/406/">WWDC 2015 Session 406：UI Testing in Xcode</a></p>

<p><a href="https://developer.apple.com/videos/play/wwdc2014/414/">WWDC 2014 Session 414：Testing in Xcode 6</a></p>

  </section>
</article>

<section class="read-more">
   
   
   <div class="read-more-item">
       <span class="read-more-item-dim">最近的文章</span>
       <h2 class="post-list__post-title post-title"><a href="/2019/03/DesignPatterns/" title="link to 学习并理解 23 种设计模式">学习并理解 23 种设计模式</a></h2>
       <p class="excerpt">  设计模式 Design Pattern 是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结，使用设计模式是为了可重用代码、让代码更容易被他人理解并且保证代码可靠性。。在《设计模式：可复用面向对象软件的基础》一书中所介绍的 23 种经典设计模式，不过设计模式并不仅仅只有这 23 种，随着软件开发行业的发展，越来越多的新模式不断诞生并得以应用。有经验的开发者在学习设计模式可以和过往的经验互相印证，更容易理解这些设计模式。设计模式一般包含模式名称、问题、目的、解决方案、效果等...&hellip;</p>
       <div class="post-list__meta"><time datetime="2019-03-03 10:40:11 +0800" class="post-list__meta--date date">2019-03-03</time> &#8226; <span class="post-list__meta--tags tags"></span><a class="btn-border-small" href=/2019/03/DesignPatterns/>继续阅读</a></div>
   </div>
   
   
   
   
   <div class="read-more-item">
       <span class="read-more-item-dim">更早的文章</span>
       <h2 class="post-list__post-title post-title"><a href="/2018/06/LLDB-in-Xcode/" title="link to WWDC 2018：效率提升爆表的 Xcode 和 LLDB 调试技巧">WWDC 2018：效率提升爆表的 Xcode 和 LLDB 调试技巧</a></h2>
       <p class="excerpt">  WWDC 2018 Session 412 : Advanced Debugging with Xcode and LLDB前言在程序员写 bug 的职业生涯中，只有 bug 会永远陪伴着你，如何处理与 bug 之间的关系，是每一位程序员的必修课。特别是入门程序员经常受 bug 的影响，熬夜加班压力大，长痘长胖还脱发。每一位 iOS 和 macOS 开发者都是幸运的，因为苹果的 Xcode 和 LLDB 调试工具，这是每一位开发者应该使用的调试神器，可以帮助我们更快地解决问题。本文将主...&hellip;</p>
       <div class="post-list__meta"><time datetime="2018-06-15 10:40:11 +0800" class="post-list__meta--date date">2018-06-15</time> &#8226; <span class="post-list__meta--tags tags"></span><a class="btn-border-small" href=/2018/06/LLDB-in-Xcode/>继续阅读</a></div>
   </div>
   
</section>

<section class="post-comments">
   
    <div id="gitalk-container"></div>
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

    <script type="text/javascript">
      var gitalk = new Gitalk({
        clientID: 'a7e3bcc8c313f6fcf2cf',
        clientSecret: '1d7f990ff0250384dea6b037ce7d6e455d84d472',
        repo: 'xietao3.github.io',
        owner: 'xietao3',
        admin: ['xietao3'],
        id: 'BlogComment',
        distractionFreeMode: true
      });
      gitalk.render('gitalk-container');

    </script>

  



  
  
  
</section>


            <section class="footer">
    <footer>
    	<span class="footer__copyright">本站点采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议</a></span>
        <span class="footer__copyright">本站由 <a href="http://xietao3.com/about">xietao3</a> 
        创建，采用 <a href="https://github.com/onevcat/vno-jekyll">Vno - Jekyll</a> 作为主题，您可以在 GitHub 找到<a href="https://github.com/onevcat/OneV-s-Den">本站源码</a> - &copy; 2016</span>
    </footer>
</section>

        </div>
    </div>
    
    <script type="text/javascript" src="//code.jquery.com/jquery-1.11.3.min.js"></script>

<script type="text/javascript" src="/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<script type="text/javascript" src="/js/main.js"></script>



    
  </body>

</html>
