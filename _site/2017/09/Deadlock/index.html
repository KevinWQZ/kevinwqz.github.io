<!DOCTYPE html>
<html>

  
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="baidu-site-verification" content="vuqzu4486i" />
  <meta name="baidu-site-verification" content="yR54QJzaFG" />
  <title>你不知道的的 iOS 多线程</title>
  <meta name="description" content="">
  <meta name="author" content="xie tao">

<!--   <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="你不知道的的 iOS 多线程">
  <meta name="twitter:description" content=""> -->
  
<!--   <meta property="og:type" content="article">
  <meta property="og:title" content="你不知道的的 iOS 多线程">
  <meta property="og:description" content=""> -->
  
  <link rel="icon" type="image/png" href="/assets/images/favicon.ico" />
  <link href="/assets/images/favicon.ico" rel="shortcut icon" type="image/png">
  
  <link rel="stylesheet" href="/css/main.css">
  <link href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">

  <link rel="canonical" href="http://localhost:4000/2017/09/Deadlock/">
  <link rel="alternate" type="application/rss+xml" title="wangquanzhen" href="http://localhost:4000/feed.xml">
  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">

  <meta name="google-site-verification" content="1-1ZlHoRvM0T2FqPbW2S-qLgYXN6rsn52kErlMPd_gw" />

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?df0994aacf7a4c9779a5632908de3196";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

  
</head>


  <body>

    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>
    
    <header class="panel-cover panel-cover--collapsed" style="background-image: url('/assets/images/background-cover.jpg')">
  <div class="panel-main">

    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/#blog" title="前往 wangquanzhen 的主页" class="blog-button"><img src="/assets/images/avatar.jpg" width="80" alt="wangquanzhen logo" class="panel-cover__logo logo" /></a>
        <h1 class="panel-cover__title panel-title"><a href="/#blog" title="前往 wangquanzhen 的主页" class="blog-button">wangquanzhen</a></h1>
        
        <span class="panel-cover__subtitle panel-subtitle">探索之旅，学习之路</span>
        
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description">你好，我是王权振！欢迎来到我的个人主页.</br>90后代码搬运工，</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />
        
        
        
        <div class="navigation-wrapper">
          <div>
            <nav class="cover-navigation cover-navigation--primary">
              <ul class="navigation">
                <li class="navigation__item"><a href="/#blog" title="进入博客" class="blog-button">博客</a></li>
                
                  <li class="navigation__item"><a href="/about/index.html" target="_blank" title="了解更多关于我">关于</a></li>
                
              </ul>
            </nav>
          </div>
          
          <div><nav class="cover-navigation navigation--social">
  <ul class="navigation">

  
  <!-- Weibo -->
  <li class="navigation__item">
  
    <a href="http://weibo.com/u/2803559240" title="xietao3 的微博" target="_blank">
    <!-- <a href="http://weibo.com/xietao3" title="xietao3 的微博" target="_blank"> -->
      <i class='social fa fa-weibo'></i>
      <span class="label">Weibo</span>
    </a>
  </li>
  

  
  <!-- Github -->
  <li class="navigation__item">
    <a href="https://github.com/xietao3" title="xietao3 的 Github" target="_blank">
      <i class='social fa fa-github'></i>
      <span class="label">Github</span>
    </a>
  </li>
  
  
  

  

  
   <!-- CSDN -->
  <li class="navigation__item">
    <a href="http://blog.csdn.net/xietao3" title="xietao3 的 CSDN" target="_blank">
      <img src="/assets/images/csdn.png" width="20" height="20" />
      <!-- <i class='social fa fa-edit'></i> -->
      <span class="label">csdn</span>
    </a>
  </li>
  

  <!-- RSS -->
<!--   <li class="navigation__item">
    <a href="/feed.xml" rel="author" title="RSS" target="_blank">
      <i class='social fa fa-rss'></i>
      <span class="label">RSS</span>
    </a>
  </li> -->

  

  </ul>
</nav>
</div>
        </div>
      </div>
    </div>
    
    
    <div class="panel-cover--overlay cover-orange"></div>
    
  </div>
</header>


    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    <div class="post-meta">
      <time datetime="2017-09-19 23:40:11 +0800" itemprop="datePublished" class="post-meta__date date">2017-09-19</time> &#8226; <span class="post-meta__tags tags"></span>
    </div>
    <h1 class="post-title">你不知道的的 iOS 多线程</h1>
  </header>

  <section class="post">
    <p><img src="http://upload-images.jianshu.io/upload_images/1319710-e5f9963ace128177.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自网络" /></p>

<blockquote>
  <p>程序员用有限的生命去追求无限的知识。</p>
</blockquote>

<h2 id="有言在先">有言在先</h2>

<p>首先我不是故意要做标题党的，也不是我要炒冷饭，我只是想换个姿势看多线程，本文大部分内容在分析如何造死锁，奈何功力尚浅，然而再浅，也需要走出第一步。打开你的 Xcode 来验证这些死锁吧。</p>

<h2 id="多线程小知识">多线程小知识</h2>
<p>以下是实现多线程的三种方式：</p>

<ul>
  <li>NSThread</li>
  <li>GCD</li>
  <li>NSOperationQueue</li>
</ul>

<p>关于<a href="http://www.jianshu.com/p/0b0d9b1f1f19">具体使用的方法</a>不再具体介绍，让我们来看看他们不为人知的一面</p>

<h4 id="1-锁的背后">1. 锁的背后</h4>

<p><code class="highlighter-rouge">NSLock</code>是基于 POSIX threads 实现的，而 POSIX threads 中使用互斥量同步线程。</p>

<p>互斥量（或称为互斥锁）是 pthread 库为解决这个问题提供的一个基本的机制。互斥量是一个锁，它保证如下三件事情：</p>

<ul>
  <li>
    <p><strong>原子性</strong> - 锁住一个互斥量是一个原子操作，表明操作系统保证如果在你已经锁了一个互斥量，那么在同一时刻就不会有其他线程能够锁住这个互斥量；</p>
  </li>
  <li>
    <p><strong>奇异性</strong> - 如果一个线程锁住了一个互斥量，那么可以保证的是在该线程释放这个锁之前没有其他线程可以锁住这个互斥量；</p>
  </li>
  <li>
    <p><strong>非忙等待</strong> - 如果一个线程（线程1）尝试去锁住一个由线程2锁住的锁，线程1会挂起（suspend）并且不会消耗任何CPU资源，直到线程2释放了这个锁。这时，线程1会唤醒并继续执行，锁住这个互斥量。</p>
  </li>
</ul>

<h4 id="2-关于生命周期">2. 关于生命周期</h4>

<p>通过 <code class="highlighter-rouge">[NSThread exit]</code> 方法使线程退出 ，<code class="highlighter-rouge">NSThread</code> 是可以立即终止正在执行的任务（可能会造成内存泄露，这里不深究）。甚至你可以在主线程中执行该操作，会使主线程也退出，app 无法再响应事件。而 <code class="highlighter-rouge">cancel</code> 可以通过作为标志位来达到类似目的，如果不做任何处理，仍然会继续执行。</p>

<p>GCD和NSOperationQueue可以取消队列中未开始执行的任务，对于已经开始执行的任务就无能为力了。</p>

<table>
  <thead>
    <tr>
      <th>实现方式\功能</th>
      <th>线程生命周期</th>
      <th>取消任务</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>NSThread</td>
      <td>手动管理</td>
      <td>立即停止执行</td>
    </tr>
    <tr>
      <td>GCD</td>
      <td>自动管理</td>
      <td>取消队列中未执行的任务</td>
    </tr>
    <tr>
      <td>NSOperationQueue</td>
      <td>自动管理</td>
      <td>取消队列中未执行的任务</td>
    </tr>
  </tbody>
</table>

<h4 id="3-并行与并发">3. 并行与并发</h4>

<p>看到很多文章里提到 <strong>并发队列</strong> ，这里有一个小陷阱，混淆了 <strong>并发</strong> 和 <strong>并行</strong> 的概念。我们先来看看一下他们之间的区别：
<img src="http://upload-images.jianshu.io/upload_images/1319710-74931f97577ac9a8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="并发与并行" /></p>

<p>从图中可以看到，并行才是真正的多线程，而并发只是在多任务中切换。一般多核CPU可以并行执行多个线程，而单核CPU实际上只有一个线程，多路复用达到接近同时执行的效果。在 iOS 中 dispatch_async 和 globalQueue 从 Xcode 中线程使用情况来看，都达到了并行的效果。</p>

<h4 id="4-队列与线程">4. 队列与线程</h4>

<p>队列是保存以及管理任务的，将任务加到队列中，任务会按照加入到队列中先后顺序依次执行。如果是全局队列和并发队列，则系统会根据系统资源去创建新的线程去处理队列中的任务，线程的创建、维护和销毁由操作系统管理，还有队列本身是线程安全的。</p>

<p>使用 NSOperationQueue 实现多线程的时候是可以控制线程总数及线程依赖关系的，而 GCD 只能选择并发或者串行队列。</p>

<h2 id="资源竞争">资源竞争</h2>
<p>多线程同时执行任务能提高程序的执行效率和响应时间，但是多线程不可避免地遇到同时操作同一资源的情况。前段时间看到的一个资源竞争的问题为例：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@property (nonatomic, strong) NSString *target; 
dispatch_queue_t queue = dispatch_queue_create("parallel", DISPATCH_QUEUE_CONCURRENT);
for (int i = 0; i &lt; 1000000 ; i++) { 
dispatch_async(queue, ^{ 
self.target = [NSString stringWithFormat:@"ksddkjalkjd%d",i]; 
}); 
}
</code></pre></div></div>

<p>解决办法：</p>

<ul>
  <li><code class="highlighter-rouge">@property (nonatomic, strong) NSString *target;</code>将<code class="highlighter-rouge">nonatomic</code>改成<code class="highlighter-rouge">atomic</code>。</li>
  <li>将并发队列 <code class="highlighter-rouge">DISPATCH_QUEUE_CONCURRENT</code> 改成串行队列 <code class="highlighter-rouge">DISPATCH_QUEUE_SERIAL</code>。</li>
  <li>异步执行<code class="highlighter-rouge">dispatch_async</code> 改成同步执行<code class="highlighter-rouge">dispatch_sync</code>。</li>
  <li>赋值使用<code class="highlighter-rouge">@synchronized</code> 或者上锁。</li>
</ul>

<p>这些方法都是从避免同时访问的角度来解决该问题，有更好的方法欢迎分享。</p>

<h2 id="花样死锁">花样死锁</h2>

<p>任何事情都有两面性，就像多线程能提升效率的同时，也会造成资源竞争的问题。而锁在保证多线程的数据安全的同时，粗心大意之下也容易发生问题，那就是 <strong>死锁</strong> 。</p>

<h4 id="1-nsoperationqueue">1. NSOperationQueue</h4>

<p>鉴于 NSOperationQueue 高度封装，使用起来非常简单，一般不会出什么幺蛾子，下面的案例展示了一个不好示范，通常我们通过控制 NSOperation 之间的从属关系，来达到有序执行任务的效果，但是如果互相从属或者循环从属都会造成所有任务无法开始。</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NSBlockOperation *blockOperation1 = [NSBlockOperation blockOperationWithBlock:^{
NSLog(@"lock 1 start");
[NSThread sleepForTimeInterval:1];
NSLog(@"lock 1 over");
}];

NSBlockOperation *blockOperation2 = [NSBlockOperation blockOperationWithBlock:^{
NSLog(@"lock 2 start");
[NSThread sleepForTimeInterval:1];
NSLog(@"lock 2 over");
}];

NSBlockOperation *blockOperation3 = [NSBlockOperation blockOperationWithBlock:^{
NSLog(@"lock 3 start");
[NSThread sleepForTimeInterval:1];
NSLog(@"lock 3 over");
}];

// 循环从属
[blockOperation2 addDependency:blockOperation1];
[blockOperation3 addDependency:blockOperation2];
[blockOperation1 addDependency:blockOperation3]; // 循环的罪魁祸首

// 互相从属
//[blockOperation1 addDependency:blockOperation2];
//[blockOperation2 addDependency:blockOperation1];

[_operationQueue addOperation:blockOperation1];
[_operationQueue addOperation:blockOperation2];
[_operationQueue addOperation:blockOperation3];
</code></pre></div></div>

<p>有没有人试过下面这种情况，如果好奇就试试吧！</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[blockOperation1 addDependency:blockOperation1];
</code></pre></div></div>

<h4 id="2-gcd">2. GCD</h4>

<p>大多数开发者都知道在主线程里同步执行任务会造成死锁，一起来看看还有哪些情况下会造成死锁或类似问题。</p>

<p>a. 在主线程同步执行 造成 <code class="highlighter-rouge">EXC_BAD_INSTRUCEION</code> 错误:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- (void)deadlock1 {
dispatch_sync(dispatch_get_main_queue(), ^{
NSLog(@"task 1 start");
[NSThread sleepForTimeInterval:1.0];
NSLog(@"task 1 over");
});
}
</code></pre></div></div>

<p>b. 和主线程同步执行类似，在串行队列中嵌套使用同步执行任务，同步队列 task1 执行完成后才能执行 task2 ，而 task1 中嵌套了task2 导致 task1 注定无法完成。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- (void)deadlock2 {
dispatch_queue_t queue = dispatch_queue_create("com.xietao3.sync", DISPATCH_QUEUE_SERIAL);

dispatch_sync(queue, ^{ // 此处异步同样会造成互相等待
NSLog(@"task 1 start");
dispatch_sync(queue, ^{
NSLog(@"task 2 start");
[NSThread sleepForTimeInterval:1.0];
NSLog(@"task 2 over");
});
NSLog(@"task 1 over");
});
}
</code></pre></div></div>
<p>嵌套同步执行任务确实很容易出 bug ，但不是绝对，将同步队列<code class="highlighter-rouge">DISPATCH_QUEUE_SERIAL</code> 换成并发队列 <code class="highlighter-rouge">DISPATCH_QUEUE_CONCURRENT</code> 这个问题就迎刃而解。修改成并发队列后案例中 task1 仍然要先执行完嵌套在其中的 task2 ，而 task2 开始执行时，并发队列不会发生互相等待导致阻塞问题 ， task2 执行完成后 task1 继续执行。</p>

<p>c. 在很多人印象中，异步执行不容易发生互相等待的情况，确实，即使是串行队列，异步任务会等待当前任务执行后再开始，除非你加了一些不健康的佐料。</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- (void)deadlock3 {
dispatch_queue_t queue = dispatch_queue_create("com.xietao3.asyn", DISPATCH_QUEUE_SERIAL);
dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);

dispatch_async(queue, ^{
__block NSString *str = @"xietao3";                             // 线程1 创建数据
dispatch_async(queue, ^{
str = [NSString stringWithFormat:@"%ld",[str hash]];        // 线程2 加工数据
dispatch_semaphore_signal(semaphore);
});
dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
NSLog(@"%@",str);                                               // 线程1 使用加工后的数据
});
}
</code></pre></div></div>

<p>d. 常规死锁，在已经上锁的情况下再次上锁，形成彼此等待的局面。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (!_lock) _lock = [NSLock new];
dispatch_queue_t queue = dispatch_queue_create("com.xietao3.sync", DISPATCH_QUEUE_CONCURRENT);

[_lock lock];
dispatch_sync(queue, ^{
[_lock lock];
[NSThread sleepForTimeInterval:1.0];
[_lock unlock];
});
[_lock unlock];
</code></pre></div></div>

<p>要解决也比较简单，将<code class="highlighter-rouge">NSLock</code>换成递归锁<code class="highlighter-rouge">NSRecursiveLock</code>，递归锁就像普通的门锁，顺时针转一圈加锁后，逆时针一圈即解锁；而如果顺时针两圈，同样逆时针两圈即可解锁。下面来一个递归的例子：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 以下代码可以理解为顺时针转10圈上锁，逆时针转10圈解锁
- (void)recursivelock:(int)count {
if (count&gt;10) return;
count++;
if (!_recursiveLock) _recursiveLock = [NSRecursiveLock new];

[_recursiveLock lock];
NSLog(@"task%d start",count);
[self recursivelock:count];
NSLog(@"task%d over",count);
[_recursiveLock unlock];
}
</code></pre></div></div>

<h4 id="3-其他">3. 其他</h4>

<p>除了上面提到的互斥锁和递归锁，其他的锁还有：</p>
<ul>
  <li>OSSpinLock(自旋锁)</li>
  <li>pthread_mutex（OC中锁的底层实现）</li>
  <li>NSConditionLock（条件锁，对于新手更容易产生死锁）</li>
  <li>NSCondition（条件锁的底层实现）</li>
  <li>@synchronized（对象锁）</li>
</ul>

<p>大部分锁触发死锁的情况和互斥锁基本一致，<code class="highlighter-rouge">NSConditionLock</code>使用起来会更加灵活，而自旋锁虽然性能爆表，但是存在漏洞，希望了解更多关于锁的知识可以<a href="http://www.jianshu.com/p/8781ff49e05b">点这里</a>，在看的同时不要忘记亲自动手验证一下，边看边写边验证，记得更加深刻。</p>

<h2 id="总结">总结</h2>

<p>关于多线程、锁的文章已经烂大街了，本文尽可能地从新的角度来看问题，尽量不写那些重复的内容，希望对你有所帮助，如果文中内容有误，欢迎指出。</p>

<p><strong>转载请注明原文：<a href="https://xietao3.com/2017/09/Deadlock/">https://xietao3.com/2017/09/Deadlock/</a></strong></p>

  </section>
</article>

<section class="read-more">
   
   
   <div class="read-more-item">
       <span class="read-more-item-dim">最近的文章</span>
       <h2 class="post-list__post-title post-title"><a href="/2017/10/BigData1/" title="link to 数据科学入门 (一) —— 数据">数据科学入门 (一) —— 数据</a></h2>
       <p class="excerpt">  Data Scientists - The Sexiest Job of the 21st Century。背景这是我们公司内部的学习兴趣班课程，并加以总结，加深巩固学习效果。一、什么是数据科学1.1 数据科学数据科学（英语：Data Science），是一门利用数据学习知识的学科，其目标是通过从数据中提取出有价值的部分来生产数据产品。它结合了诸多领域中的理论和技术，包括应用数学，统计，模式识别，机器学习，数据可视化，数据仓库，以及高性能计算。数据科学通过用运用各种相关的数据来帮助非专...&hellip;</p>
       <div class="post-list__meta"><time datetime="2017-10-23 19:40:11 +0800" class="post-list__meta--date date">2017-10-23</time> &#8226; <span class="post-list__meta--tags tags"></span><a class="btn-border-small" href=/2017/10/BigData1/>继续阅读</a></div>
   </div>
   
   
   
   
   <div class="read-more-item">
       <span class="read-more-item-dim">更早的文章</span>
       <h2 class="post-list__post-title post-title"><a href="/2017/06/bezierPath/" title="link to 包教包会-贝塞尔曲线的绘制原理与应用">包教包会-贝塞尔曲线的绘制原理与应用</a></h2>
       <p class="excerpt">  说来话长，这一切都得从PhotoShop中的钢笔工具开始说起…声明：本文不含复杂数学公式，学渣放心阅读吧😂(我仿佛看到了学渣们留下了激动的泪水)背景贝塞尔曲线(Bézier curve)是应用于二维图形应用程序的数学曲线，贝塞尔曲线基于多个点构成。它的应用非常广泛，比如说PS中的钢笔工具所绘画的曲线就是贝塞尔曲线，绘制动画的运动轨迹等等，而最近一次想用到贝塞尔曲线是想做一个 路径动画 。简介在iOS开发中一般通过UIBezierPath来实现贝塞尔曲线的绘制，平时一般使用绘制二阶和三阶...&hellip;</p>
       <div class="post-list__meta"><time datetime="2017-06-22 22:03:11 +0800" class="post-list__meta--date date">2017-06-22</time> &#8226; <span class="post-list__meta--tags tags"></span><a class="btn-border-small" href=/2017/06/bezierPath/>继续阅读</a></div>
   </div>
   
</section>

<section class="post-comments">
   
    <div id="gitalk-container"></div>
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

    <script type="text/javascript">
      var gitalk = new Gitalk({
        clientID: 'a7e3bcc8c313f6fcf2cf',
        clientSecret: '1d7f990ff0250384dea6b037ce7d6e455d84d472',
        repo: 'xietao3.github.io',
        owner: 'xietao3',
        admin: ['xietao3'],
        id: 'BlogComment',
        distractionFreeMode: true
      });
      gitalk.render('gitalk-container');

    </script>

  



  
  
  
</section>


            <section class="footer">
    <footer>
    	<span class="footer__copyright">本站点采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议</a></span>
        <span class="footer__copyright">本站由 <a href="http://xietao3.com/about">xietao3</a> 
        创建，采用 <a href="https://github.com/onevcat/vno-jekyll">Vno - Jekyll</a> 作为主题，您可以在 GitHub 找到<a href="https://github.com/onevcat/OneV-s-Den">本站源码</a> - &copy; 2016</span>
    </footer>
</section>

        </div>
    </div>
    
    <script type="text/javascript" src="//code.jquery.com/jquery-1.11.3.min.js"></script>

<script type="text/javascript" src="/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<script type="text/javascript" src="/js/main.js"></script>



    
  </body>

</html>
