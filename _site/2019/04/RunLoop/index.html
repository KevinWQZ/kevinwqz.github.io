<!DOCTYPE html>
<html>

  
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="baidu-site-verification" content="vuqzu4486i" />
  <meta name="baidu-site-verification" content="yR54QJzaFG" />
  <title>RunLoop 学习笔记</title>
  <meta name="description" content="  对本文感兴趣的同学可以查看本文 Demo ，其中实现了本文大部分相关内容。本文在部分基础概念知识点借鉴(copy)了参考文章内容，望包涵。">
  <meta name="author" content="xie tao">

<!--   <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="RunLoop 学习笔记">
  <meta name="twitter:description" content="  对本文感兴趣的同学可以查看本文 Demo ，其中实现了本文大部分相关内容。本文在部分基础概念知识点借鉴(copy)了参考文章内容，望包涵。"> -->
  
<!--   <meta property="og:type" content="article">
  <meta property="og:title" content="RunLoop 学习笔记">
  <meta property="og:description" content="  对本文感兴趣的同学可以查看本文 Demo ，其中实现了本文大部分相关内容。本文在部分基础概念知识点借鉴(copy)了参考文章内容，望包涵。"> -->
  
  <link rel="icon" type="image/png" href="/assets/images/favicon.ico" />
  <link href="/assets/images/favicon.ico" rel="shortcut icon" type="image/png">
  
  <link rel="stylesheet" href="/css/main.css">
  <link href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">

  <link rel="canonical" href="http://localhost:4000/2019/04/RunLoop/">
  <link rel="alternate" type="application/rss+xml" title="wangquanzhen" href="http://localhost:4000/feed.xml">
  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">

  <meta name="google-site-verification" content="1-1ZlHoRvM0T2FqPbW2S-qLgYXN6rsn52kErlMPd_gw" />

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?df0994aacf7a4c9779a5632908de3196";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

  
</head>


  <body>

    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>
    
    <header class="panel-cover panel-cover--collapsed" style="background-image: url('/assets/images/background-cover.jpg')">
  <div class="panel-main">

    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/#blog" title="前往 wangquanzhen 的主页" class="blog-button"><img src="/assets/images/avatar.jpg" width="80" alt="wangquanzhen logo" class="panel-cover__logo logo" /></a>
        <h1 class="panel-cover__title panel-title"><a href="/#blog" title="前往 wangquanzhen 的主页" class="blog-button">wangquanzhen</a></h1>
        
        <span class="panel-cover__subtitle panel-subtitle">探索之旅，学习之路</span>
        
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description">你好，我是王权振！欢迎来到我的个人主页.</br>90后代码搬运工，</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />
        
        
        
        <div class="navigation-wrapper">
          <div>
            <nav class="cover-navigation cover-navigation--primary">
              <ul class="navigation">
                <li class="navigation__item"><a href="/#blog" title="进入博客" class="blog-button">博客</a></li>
                
                  <li class="navigation__item"><a href="/about/index.html" target="_blank" title="了解更多关于我">关于</a></li>
                
              </ul>
            </nav>
          </div>
          
          <div><nav class="cover-navigation navigation--social">
  <ul class="navigation">

  
  <!-- Weibo -->
  <li class="navigation__item">
  
    <a href="http://weibo.com/u/2803559240" title="xietao3 的微博" target="_blank">
    <!-- <a href="http://weibo.com/xietao3" title="xietao3 的微博" target="_blank"> -->
      <i class='social fa fa-weibo'></i>
      <span class="label">Weibo</span>
    </a>
  </li>
  

  
  <!-- Github -->
  <li class="navigation__item">
    <a href="https://github.com/xietao3" title="xietao3 的 Github" target="_blank">
      <i class='social fa fa-github'></i>
      <span class="label">Github</span>
    </a>
  </li>
  
  
  

  

  
   <!-- CSDN -->
  <li class="navigation__item">
    <a href="http://blog.csdn.net/xietao3" title="xietao3 的 CSDN" target="_blank">
      <img src="/assets/images/csdn.png" width="20" height="20" />
      <!-- <i class='social fa fa-edit'></i> -->
      <span class="label">csdn</span>
    </a>
  </li>
  

  <!-- RSS -->
<!--   <li class="navigation__item">
    <a href="/feed.xml" rel="author" title="RSS" target="_blank">
      <i class='social fa fa-rss'></i>
      <span class="label">RSS</span>
    </a>
  </li> -->

  

  </ul>
</nav>
</div>
        </div>
      </div>
    </div>
    
    
    <div class="panel-cover--overlay cover-orange"></div>
    
  </div>
</header>


    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    <div class="post-meta">
      <time datetime="2019-04-30 10:40:11 +0800" itemprop="datePublished" class="post-meta__date date">2019-04-30</time> &#8226; <span class="post-meta__tags tags"></span>
    </div>
    <h1 class="post-title">RunLoop 学习笔记</h1>
  </header>

  <section class="post">
    <blockquote>
  <p>对本文感兴趣的同学可以查看本文 <a href="https://github.com/xietao3/Study-Plan/blob/master/RunLoop/Demo">Demo</a> ，其中实现了本文大部分相关内容。本文在部分基础概念知识点借鉴(copy)了参考文章内容，望包涵。</p>
</blockquote>

<h2 id="一runloop">一、RunLoop</h2>

<h3 id="11-runloop-的概念">1.1 RunLoop 的概念</h3>

<p><code class="highlighter-rouge">RunLoop</code>和线程是一对一的关系，通常来讲线程执行完任务之后就会退出，有时候我们需要一个常驻线程帮我们处理事件，处理完成也不会退出，等待下一次处理事件。</p>

<p>这种机制一般称作为 <strong>事件循环机制(EventLoop)</strong> ，RunLoop 管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面<code class="highlighter-rouge">EventLoop</code>的逻辑。线程执行了这个函数后，就会一直处于这个函数内部 <code class="highlighter-rouge">接受消息-&gt;等待-&gt;处理</code> 的循环中。当没有事件的时候进入休眠状态，避免占用资源，一旦受到事件就将被唤醒来处理事件，直到这个循环结束，函数返回。</p>

<h3 id="12-获得-runloop">1.2 获得 RunLoop</h3>

<p>苹果不允许直接创建<code class="highlighter-rouge">RunLoop</code>，它只提供了两个自动获取的函数：<code class="highlighter-rouge">CFRunLoopGetMain()</code>和 <code class="highlighter-rouge">CFRunLoopGetCurrent()</code>。你可以在任意线程获得主线程的<code class="highlighter-rouge">RunLoop</code>，除此之外只能获得本线程的<code class="highlighter-rouge">RunLoop</code>。</p>

<p>除了主线程之外，其他线程的<code class="highlighter-rouge">RunLoop</code>都需要手动运行。API 提供了 3 种运行方式：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- (void)run; 
- (void)runUntilDate:(NSDate *)limitDate;
- (BOOL)runMode:(NSRunLoopMode)mode beforeDate:(NSDate *)limitDate;
</code></pre></div></div>

<ul>
  <li>
    <p><code class="highlighter-rouge">run</code> 即使调用<code class="highlighter-rouge">CFRunLoopStop()</code>也无法退出，通常如果想要永远不会退出<code class="highlighter-rouge">RunLoop</code>才会使用此方法，否则可以使用另外 2 种方式 。</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">runUntilDate:</code>执行完并不会退出，继续执行下去直到你设置的结束时间，<code class="highlighter-rouge">CFRunLoopStop()</code>同样无效。</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">runMode:beforeDate:</code>通过该方法启动时，只能执行一次，执行完就退出，此方法可以使用<code class="highlighter-rouge">CFRunLoopStop()</code>提前退出。</p>
  </li>
</ul>

<h3 id="13-cfrunloop">1.3 CFRunLoop</h3>

<p>NSRunLoop 是在 CFRunLoop 的基础上进行封装，有希望了解实现原理的可以查看 <a href="https://opensource.apple.com/source/CF/CF-855.17/">RunLoop 源码</a> 。</p>

<p>CFRunLoop 相关的函数基本和 NSRunLoop 一致。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CF_EXPORT CFRunLoopRef CFRunLoopGetCurrent(void);
CF_EXPORT CFRunLoopRef CFRunLoopGetMain(void);

CF_EXPORT void CFRunLoopRun(void);
CF_EXPORT SInt32 CFRunLoopRunInMode(CFStringRef mode, CFTimeInterval seconds, Boolean returnAfterSourceHandled);
CF_EXPORT Boolean CFRunLoopIsWaiting(CFRunLoopRef rl);
CF_EXPORT void CFRunLoopWakeUp(CFRunLoopRef rl);
CF_EXPORT void CFRunLoopStop(CFRunLoopRef rl);
</code></pre></div></div>

<p>下面是 CFRunLoop 的基本结构：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct __CFRunLoop {
    CFRuntimeBase _base;			
    pthread_mutex_t _lock;			/* locked for accessing mode list */
    __CFPort _wakeUpPort;			// used for CFRunLoopWakeUp 
    Boolean _unused;
    volatile _per_run_data *_perRunData;    // reset for runs of the run loop
    pthread_t _pthread;
    uint32_t _winthread;
    CFMutableSetRef _commonModes;    
    CFMutableSetRef _commonModeItems;
    CFRunLoopModeRef _currentMode;
    CFMutableSetRef _modes;
    struct _block_item *_blocks_head;
    struct _block_item *_blocks_tail;
    CFTypeRef _counterpart;
};
</code></pre></div></div>

<p>在 CFRunLoop 的结构当中，有很多与 Mode 相关的属性，比如说<code class="highlighter-rouge">_commonModes</code>、<code class="highlighter-rouge">_commonModeItems</code>、<code class="highlighter-rouge">_currentMode</code>和<code class="highlighter-rouge">_modes</code>等等，继续往下看了解他们的关系。</p>

<h2 id="二mode">二、Mode</h2>

<h3 id="21-mode-的概念">2.1 Mode 的概念</h3>

<p>一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Mode Item ，如 Source、Timer、Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source、Timer、Observer，让其互不影响。</p>

<p>主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两个 Mode 都已经被标记为<code class="highlighter-rouge">Common</code>属性。</p>

<ul>
  <li>
    <p>DefaultMode 是 App 平时所处的状态</p>
  </li>
  <li>
    <p>TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。</p>
  </li>
  <li>
    <p>CommonModes 并不是一个真的 Mode ，它是一个 Mode 的集合，可以将其他 Mode 加入其中。</p>
  </li>
</ul>

<p>除此之外还有一些开发者不常用的 Mode 可以在 <a href="http://iphonedevwiki.net/index.php/CFRunLoop">http://iphonedevwiki.net/index.php/CFRunLoop</a> 查看。</p>

<p>CF 中获得 Mode 的方式：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CF_EXPORT CFStringRef CFRunLoopCopyCurrentMode(CFRunLoopRef rl);
CF_EXPORT CFArrayRef CFRunLoopCopyAllModes(CFRunLoopRef rl);
</code></pre></div></div>

<h3 id="22-commonmodes">2.2 CommonModes</h3>

<p>Mode 有个概念叫 <strong>CommonModes</strong> ：一个 Mode 可以将自己标记为<code class="highlighter-rouge">Common</code>属性，通过将其 ModeName 添加到 RunLoop 的<code class="highlighter-rouge">commonModes</code>中。每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItems 里的 Source、Observer、Timer 同步到具有<code class="highlighter-rouge">Common</code>标记的所有 Mode 里。</p>

<p>当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个 ScrollView 时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。如果你将以上两种 Mode 都标记成 CommonModes ，并且将 Timer 将入 CommonModes 中，那不管 ScrollView 是否滑动， Timer 都会执行回调。</p>

<p>将一个 Mode 加入 CommonMode 源代码：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void CFRunLoopAddCommonMode(CFRunLoopRef rl, CFStringRef modeName) {
	...
	// 不包含在 _commonModes 当中
    if (!CFSetContainsValue(rl-&gt;_commonModes, modeName)) {
    // 获得 RunLoop 的 _commonModeItems
	CFSetRef set = rl-&gt;_commonModeItems ? CFSetCreateCopy(kCFAllocatorSystemDefault, rl-&gt;_commonModeItems) : NULL;
	// 将 Mode 加入 _commonModes 中
	CFSetAddValue(rl-&gt;_commonModes, modeName);
	// 如果 _commonModeItems 有值则加入当前 Mode 中
	if (NULL != set) {
	    CFTypeRef context[2] = {rl, modeName};
	    /* add all common-modes items to new mode */
	    CFSetApplyFunction(set, (__CFRunLoopAddItemsToCommonMode), (void *)context);
	    CFRelease(set);
	}
    } else {
    }
    __CFRunLoopUnlock(rl);
}

</code></pre></div></div>

<h3 id="23-mode-items">2.3 Mode Items</h3>

<p>Source、Timer、Observer 对应 CFRunLoop 源代码结构中 Source0、Source1、Timer 和待执行的 block 被统称为 Mode Item ，一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环，所有大家需要建立一个常驻线程的话，至少要在该线程 RunLoop 中加入一个 Mode Item。</p>

<p>CFRunLoop 管理 Mode Items 相关接口：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CF_EXPORT Boolean CFRunLoopContainsSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef mode);
CF_EXPORT void CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef mode);
CF_EXPORT void CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef mode);

CF_EXPORT Boolean CFRunLoopContainsObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef mode);
CF_EXPORT void CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef mode);
CF_EXPORT void CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef mode);

CF_EXPORT Boolean CFRunLoopContainsTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);
CF_EXPORT void CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);
CF_EXPORT void CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);
</code></pre></div></div>

<p>下面是 CFRunLoopMode 检查 Mode Items 是否为空的源代码：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>static Boolean __CFRunLoopModeIsEmpty(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFRunLoopModeRef previousMode) {
	...
    // 主线程 GCD 也和后面一些内容有关
    if (libdispatchQSafe &amp;&amp; (CFRunLoopGetMain() == rl) &amp;&amp; CFSetContainsValue(rl-&gt;_commonModes, rlm-&gt;_name)) return false; // represents the libdispatch main queue
    // 检查 Source0
    if (NULL != rlm-&gt;_sources0 &amp;&amp; 0 &lt; CFSetGetCount(rlm-&gt;_sources0)) return false;
    // 检查 source1
    if (NULL != rlm-&gt;_sources1 &amp;&amp; 0 &lt; CFSetGetCount(rlm-&gt;_sources1)) return false;
    // 检查 Timer
    if (NULL != rlm-&gt;_timers &amp;&amp; 0 &lt; CFArrayGetCount(rlm-&gt;_timers)) return false;
    // 检查 Block
    struct _block_item *item = rl-&gt;_blocks_head;
    while (item) {
        struct _block_item *curr = item;
        item = item-&gt;_next;
        Boolean doit = false;
        if (CFStringGetTypeID() == CFGetTypeID(curr-&gt;_mode)) {
            doit = CFEqual(curr-&gt;_mode, rlm-&gt;_name) || (CFEqual(curr-&gt;_mode, kCFRunLoopCommonModes) &amp;&amp; CFSetContainsValue(rl-&gt;_commonModes, rlm-&gt;_name));
        } else {
            doit = CFSetContainsValue((CFSetRef)curr-&gt;_mode, rlm-&gt;_name) || (CFSetContainsValue((CFSetRef)curr-&gt;_mode, kCFRunLoopCommonModes) &amp;&amp; CFSetContainsValue(rl-&gt;_commonModes, rlm-&gt;_name));
        }
        if (doit) return false;
    }
    return true;
}
</code></pre></div></div>

<h3 id="24-cfrunloopmode">2.4 CFRunLoopMode</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct __CFRunLoopMode {
    CFRuntimeBase _base;
    pthread_mutex_t _lock;	/* must have the run loop locked before locking this */
    CFStringRef _name;
    Boolean _stopped;
    char _padding[3];
    CFMutableSetRef _sources0;
    CFMutableSetRef _sources1;
    CFMutableArrayRef _observers;
    CFMutableArrayRef _timers;
    CFMutableDictionaryRef _portToV1SourceMap;
    __CFPortSet _portSet;
    CFIndex _observerMask;
#if USE_DISPATCH_SOURCE_FOR_TIMERS
    dispatch_source_t _timerSource;
    dispatch_queue_t _queue;
    Boolean _timerFired; // set to true by the source when a timer has fired
    Boolean _dispatchTimerArmed;
#endif
#if USE_MK_TIMER_TOO
    mach_port_t _timerPort;
    Boolean _mkTimerArmed;
#endif
#if DEPLOYMENT_TARGET_WINDOWS
    DWORD _msgQMask;
    void (*_msgPump)(void);
#endif
    uint64_t _timerSoftDeadline; /* TSR */
    uint64_t _timerHardDeadline; /* TSR */
};
</code></pre></div></div>

<p>在 CFRunLoopMode 的结构中，最重要的 _sources0 、 _sources1 、 _observers 和 timers 后面会一一介绍。</p>

<h2 id="三source">三、Source</h2>

<p>CFRunLoopSourceRef 是事件产生的来源。从 CFRunLoopMode 的结构中可以发现 Source 有两个种：Source0 和 Source1。</p>

<ul>
  <li>
    <p><strong>Source0</strong>：只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。</p>
  </li>
  <li>
    <p><strong>Source1</strong>：包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。</p>
  </li>
</ul>

<h3 id="31-利用-sourcesource0-跨线程通信">3.1 利用 Source(Source0) 跨线程通信</h3>

<p>利用 Source(Source0) 跨线程通信整个流程大致分为:</p>

<ul>
  <li>创建 <code class="highlighter-rouge">CFRunLoopSourceContext</code></li>
  <li>创建 <code class="highlighter-rouge">CFRunLoopSourceRef</code></li>
  <li>将<code class="highlighter-rouge">CFRunLoopSourceRef</code>加入当前线程 RunLoop</li>
  <li>通过 <code class="highlighter-rouge">CFRunLoopSourceRef</code> 发送信号并唤醒 RunLoop 处理</li>
</ul>

<p>文章中的全部 OC 代码可以在本文 <a href="https://github.com/xietao3/Study-Plan/blob/master/RunLoop/Demo">Demo</a> 中找到。</p>

<p>下面的代码展示了如何创建<code class="highlighter-rouge">CFRunLoopSourceContext</code>，并借此创建<code class="highlighter-rouge">CFRunLoopSourceRef</code>，最后将<code class="highlighter-rouge">CFRunLoopSourceRef</code>加入到 RunLoop 中。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- (void)setup {
	// 初始化 CFRunLoopSourceContext
    CFRunLoopSourceContext  context = {0, (__bridge void *)(self), NULL, NULL, NULL, NULL, NULL,
        &amp;RunLoopSourceScheduleCallBack,
        RunLoopSourceCancelCallBack,
        RunLoopSourcePerformCallBack};
        
    // 创建 CFRunLoopSourceRef
    self.runLoopSource = CFRunLoopSourceCreate(NULL, 0, &amp;context);
    // 保存当前线程 runloop
    self.runLoop = CFRunLoopGetCurrent();
}

// 将 CFRunLoopSourceRef 加入当前线程 RunLoop
- (void)addToCurrentRunLoopWithKey:(NSString *)key {
    self.name = key;
    // 将 Source 加入 RunLoop
    CFRunLoopAddSource(CFRunLoopGetCurrent(), _runLoopSource, kCFRunLoopDefaultMode);
    // 将自定义 Source 对象存储起来，方便外部通过 Key 获取
    [RunLoopItemCenter addSource:self withKey:key];
}

</code></pre></div></div>

<p>查看<code class="highlighter-rouge">CFRunLoopSourceContext</code>结构可以得到一些关键信息，比如说如何传递信息，如何获得各种回调。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef struct {
    CFIndex	version;
    void *	info;		// 传递信息
    const void *(*retain)(const void *info);
    void	(*release)(const void *info);
    CFStringRef	(*copyDescription)(const void *info);
    Boolean	(*equal)(const void *info1, const void *info2);
    CFHashCode	(*hash)(const void *info);
    void	(*schedule)(void *info, CFRunLoopRef rl, CFRunLoopMode mode); // 加载回调
    void	(*cancel)(void *info, CFRunLoopRef rl, CFRunLoopMode mode); // 卸载回调
    void	(*perform)(void *info);	// 执行回调
} CFRunLoopSourceContext;

</code></pre></div></div>

<p>加入<code class="highlighter-rouge">CFRunLoopSourceContext</code>的各种回调处理事件。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 装载回调
void RunLoopSourceScheduleCallBack (void *info, CFRunLoopRef rl, CFStringRef mode) {
    RunLoopSource *source = (__bridge RunLoopSource *)(info);
    NSLog(@"加入 Source：%@", source.name);
}

// 处理回调 info 在 CFRunLoopSourceContext 中传入
void RunLoopSourcePerformCallBack (void *info) {
    RunLoopSource *source = (__bridge RunLoopSource *)(info);
    NSLog(@"通知处理 Source：%@", source.name);
}

// 卸载回调
void RunLoopSourceCancelCallBack (void *info, CFRunLoopRef rl, CFStringRef mode) {
    RunLoopSource *source = (__bridge RunLoopSource *)(info);
    NSLog(@"移除 Source：%@", source.name);
    [RunLoopItemCenter removeSourceWithKey:source.name];
}
</code></pre></div></div>

<p>接下来就可以利用下面的方法发送信号，通知 RunLoop 处理事件。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[RunLoopSource fireSourceWithKey:kBackgroundThreadSourceKey1];

+ (void)fireSourceWithKey:(NSString *)key {
	// 通过 key 取出对应的 RunLoopSource
    RunLoopSource *source = [RunLoopItemCenter getSourceWithKey:key];
    if (source) {
    	// 需要先发信号 然后再唤醒 RunLoop
        CFRunLoopSourceSignal(source.runLoopSource);
        CFRunLoopWakeUp(source.runLoop);
    }
}
</code></pre></div></div>

<h3 id="32-nsport">3.2 NSPort</h3>

<p>利用 NSPort(Source1) 跨线程通信整个流程大致分为:</p>

<ul>
  <li>设置线程 1 端口及事件代理</li>
  <li>设置线程 2 端口及事件代理</li>
  <li>从线程 1 发送消息至线程 2</li>
  <li>线程 2 回复消息至 线程 1</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- (void)setup {
    // 创建主线程 RunLoop 端口 _mainPort
    _mainPort = [[NSMachPort alloc]init];
    // 设置 主线程端口处理事件代理
    _mainPortDelegate = [[RunLoopMainPortDelegate alloc] init];
    _mainPort.delegate = (id)_mainPortDelegate;
    // 将端口加入主线程 RunLoop
    [[NSRunLoop mainRunLoop] addPort:_mainPort forMode:NSDefaultRunLoopMode];
    
    // 创建子线程端口 _threadPort
    _threadPort = [NSMachPort port];
    // 设置处理事件代理
    _threadPort.delegate = self;
    
}

// 将子线程端口加入子线程 RunLoop 并且保存，方便后面获取调用
- (void)addPortToCurrentRunLoopWithKey:(NSString *)key {
    [[NSRunLoop currentRunLoop]addPort:_threadPort forMode:NSDefaultRunLoopMode];
    [RunLoopItemCenter addPort:self withKey:key];
}
</code></pre></div></div>

<p>处理主线程端口代理事件：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@implementation RunLoopMainPortDelegate

- (void)handlePortMessage:(id)message {
    NSArray *components = [message valueForKeyPath:@"components"];
    NSData *data =  components[0];
    NSString *s1 = [[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding];
    NSLog(@"当前线程：%@",[NSThread currentThread]);
    NSLog(@"收到消息:%@",s1);
}

@end
</code></pre></div></div>

<p>处理子线程端口事件：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- (void)handlePortMessage:(id)message {
    NSArray *components = [message valueForKeyPath:@"components"];
    NSMachPort *localPort = [message valueForKeyPath:@"localPort"];
    NSMachPort *remotePort = [message valueForKeyPath:@"remotePort"];

    NSData *data =  components[0];
    NSString *s1 = [[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding];
    NSLog(@"当前线程：%@",[NSThread currentThread]);
    NSLog(@"收到消息:%@",s1);
    
    // 收到消息后回复对方端口
    [self replyWithLocalPort:remotePort remotePort:localPort];
}

- (void)replyWithLocalPort:(NSPort *)localPort remotePort:(NSPort *)remotePort {
    NSMutableArray *components = [NSMutableArray arrayWithArray:@[[@"这是回复" dataUsingEncoding:NSUTF8StringEncoding]]];
    [localPort sendBeforeDate:[NSDate date] msgid:200 components:components from:remotePort reserved:0];
}
</code></pre></div></div>

<p>一切就绪可以进行通信了：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[RunLoopPort sendPortWithMessage:@"xietao3" key:kBackgroundThreadPortKey];

+ (void)sendPortWithMessage:(NSString *)message key:(NSString *)key {
	// 获取保存端口对象
    RunLoopPort *runLoopPort = [RunLoopItemCenter getPortWithKey:key];
    if (runLoopPort) {
        NSData *data = [message dataUsingEncoding:NSUTF8StringEncoding];
        NSMutableArray *components = [NSMutableArray arrayWithArray:@[data]];
        // 通过子线程端口发送消息
        [runLoopPort.threadPort sendBeforeDate:[NSDate date] msgid:100 components:components from:runLoopPort.mainPort reserved:0];
    }
}
</code></pre></div></div>

<p>子线程在收到信息后，对主线程进行了回复：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>当前线程：&lt;NSThread: 0x6000035b25c0&gt;{number = 3, name = BackgroundThread}
收到消息:xietao3
当前线程：&lt;NSThread: 0x6000035c2900&gt;{number = 1, name = main}
收到消息:这是回复
</code></pre></div></div>

<h2 id="四timer">四、Timer</h2>

<p>CFRunLoopTimerRef 是基于时间的触发器，它和 NSTimer 是 toll-free bridged （免费桥，可以互相转换）的。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。</p>

<p>Timer 在开发中比较常用，有部分初级的开发者在不了解 Timer 与 Mode 之间关系，会发现 Timer 在滑动时无法调用。这是因为滑动 ScrollView 时主线程 RunLoop 切换成 UITrackingRunLoopMode 模式，这是为了提升滑动时的用户体验。解决问题的办法有 2 种：</p>

<ul>
  <li>将 Timer 加入 CommomModes ，2 种 Mode 都被包含在其中，所以 Timer 在加入时会分别加入 CommonMode 中的每一个 Mode 。</li>
  <li>将 Timer 加入子线程，子线程没有 UITrackingRunLoopMode ，在滑动时不会受影响。</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;CFRunLoop 0x600000f64600 [0x10712bb68]&gt;{wakeup port = 0x1e07, stopped = false, ignoreWakeUps = true, 
current mode = kCFRunLoopDefaultMode,
common modes = &lt;CFBasicHash 0x600003d68810 [0x10712bb68]&gt;{type = mutable set, count = 2,
entries =&gt;
	0 : &lt;CFString 0x10a653be0 [0x10712bb68]&gt;{contents = "UITrackingRunLoopMode"}
	2 : &lt;CFString 0x107141168 [0x10712bb68]&gt;{contents = "kCFRunLoopDefaultMode"}
}
...

</code></pre></div></div>

<p>在调试模式中通过 LLBD 指令<code class="highlighter-rouge">po CFRunLoopGetCurrent()</code>可以查看当前 RunLoop 具体信息。</p>

<p>下面是子线程的 RunLoop 结构：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;CFRunLoop 0x600003798000 [0x105559b68]&gt;{wakeup port = 0x9f07, stopped = false, ignoreWakeUps = false, 

// 当前 Mode
current mode = kCFRunLoopDefaultMode,

// RunLoop 的 Common Modes
common modes = &lt;CFBasicHash 0x600000596520 [0x105559b68]&gt;{type = mutable set, count = 1,
entries =&gt;
	2 : &lt;CFString 0x10556f168 [0x105559b68]&gt;{contents = "kCFRunLoopDefaultMode"}
}
,

// Common Mode Items
common mode items = &lt;CFBasicHash 0x6000005c92f0 [0x105559b68]&gt;{type = mutable set, count = 1,
entries =&gt;
	2 : &lt;CFRunLoopSource 0x600003e94e40 [0x105559b68]&gt;{signalled = No, valid = Yes, order = 0, context = &lt;CFRunLoopSource context&gt;{version = 0, info = 0x60000098c7e0, callout = __NSThreadPerformPerform (0x10431eb31)}}
}
,

// RunLoop 拥有的 Mode
modes = &lt;CFBasicHash 0x600000595110 [0x105559b68]&gt;{type = mutable set, count = 1,
entries =&gt;
	2 : &lt;CFRunLoopMode 0x600003094750 [0x105559b68]&gt;{name = kCFRunLoopDefaultMode, port set = 0x6007, queue = 0x600002595c00, source = 0x600002595980 (not fired), timer port = 0x5e0b, 
	
	// 该 Mode 里的 Source 0 有 3 个
	sources0 = &lt;CFBasicHash 0x600000596ac0 [0x105559b68]&gt;{type = mutable set, count = 3,
entries =&gt;
	0 : &lt;CFRunLoopSource 0x600003e94e40 [0x105559b68]&gt;{signalled = No, valid = Yes, order = 0, context = &lt;CFRunLoopSource context&gt;{version = 0, info = 0x60000098c7e0, callout = __NSThreadPerformPerform (0x10431eb31)}}
	1 : &lt;CFRunLoopSource 0x600003e989c0 [0x105559b68]&gt;{signalled = No, valid = Yes, order = 0, context = &lt;CFRunLoopSource context&gt;{version = 0, info = 0x600000b94940, callout = RunLoopSourcePerformCallBack (0x103f5e0c0)}}
	2 : &lt;CFRunLoopSource 0x600003e91740 [0x105559b68]&gt;{signalled = No, valid = Yes, order = 0, context = &lt;CFRunLoopSource context&gt;{version = 0, info = 0x600000bc8720, callout = RunLoopSourcePerformCallBack (0x103f5e0c0)}}
}
,
	
	// 该 Mode 里的 Source1 有 2 个
	sources1 = &lt;CFBasicHash 0x6000005968e0 [0x105559b68]&gt;{type = mutable set, count = 2,
entries =&gt;
	0 : &lt;CFRunLoopSource 0x600003e9fcc0 [0x105559b68]&gt;{signalled = No, valid = Yes, order = 200, context = &lt;CFMachPort 0x600003c9c840 [0x105559b68]&gt;{valid = Yes, port = 6b03, source = 0x600003e9fcc0, callout = __NSFireMachPort (0x10430337f), context = &lt;CFMachPort context 0x60000059bde0&gt;}}
	2 : &lt;CFRunLoopSource 0x600003e99140 [0x105559b68]&gt;{signalled = No, valid = Yes, order = 200, context = &lt;CFMachPort 0x600003c980b0 [0x105559b68]&gt;{valid = Yes, port = a307, source = 0x600003e99140, callout = __NSFireMachPort (0x10430337f), context = &lt;CFMachPort context 0x600000596d30&gt;}}
}
,
	
	// Mode 里的 Observer
	observers = (null),
	
	// Mode 里的 Timer
	timers = &lt;CFArray 0x600002f8f8a0 [0x105559b68]&gt;{type = mutable-small, count = 2, values = (
	0 : &lt;CFRunLoopTimer 0x600003e90fc0 [0x105559b68]&gt;{valid = Yes, firing = No, interval = 2, tolerance = 0, next fire date = 578243733 (-14.179448 @ 95022246756349), callout = (NSTimer) [_NSTimerBlockTarget fire:] (0x10432882e / 0x104327e94) (/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/System/Library/Frameworks/Foundation.framework/Foundation), context = &lt;CFRunLoopTimer context 0x600000bc86a0&gt;}
	1 : &lt;CFRunLoopTimer 0x600003e95980 [0x105559b68]&gt;{valid = Yes, firing = No, interval = 3.061152e+09, tolerance = 0, next fire date = 1.08315496e+09 (504911215 @ 505006251110144887), callout = __28+[BackgroundThread addTimer]_block_invoke (0x10524aa80 / 0x103f5dbe0) (/Users/xietao/Library/Developer/CoreSimulator/Devices/A7E23433-02D3-4BEE-A48D-E5633884E274/data/Containers/Bundle/Application/F6A347C6-7AD1-4C3B-81CE-A33C41D192D7/RunLoopDemo.app/RunLoopDemo), context = &lt;CFRunLoopTimer context 0x103f62198&gt;}
)},
	currently 578243747 (95036425793208) / soft deadline in: 1.84467441e+10 sec (@ 95022246756349) / hard deadline in: 1.84467441e+10 sec (@ 95022246756349)
},

}
}
</code></pre></div></div>

<h2 id="五observer">五、Observer</h2>

<p>CFRunLoopObserverRef 是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {
    kCFRunLoopEntry         = (1UL &lt;&lt; 0), // 即将进入Loop
    kCFRunLoopBeforeTimers  = (1UL &lt;&lt; 1), // 即将处理 Timer
    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source
    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠
    kCFRunLoopAfterWaiting  = (1UL &lt;&lt; 6), // 刚从休眠中唤醒
    kCFRunLoopExit          = (1UL &lt;&lt; 7), // 即将退出Loop
};
</code></pre></div></div>

<p>目前已经很多小伙伴利用 Observer 进入休眠的时长来实现卡顿检测的功能，除了上述的 Observer 之外主线程会额外注册一些 Observer ：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>observers = (
    "&lt;CFRunLoopObserver 0x6000011443c0 [0x10aa86b68]&gt;{valid = Yes, activities = 0x1, repeats = Yes, order = -2147483647, 
    callout = _wrapRunLoopWithAutoreleasePoolHandler (0x10d7591b1), context = &lt;CFArray 0x600002e54ed0 [0x10aa86b68]&gt;{type = mutable-small, count = 1, values = (\n\t0 : &lt;0x7fbbc4002058&gt;\n)}}",
    
    "&lt;CFRunLoopObserver 0x60000114c320 [0x10aa86b68]&gt;{valid = Yes, activities = 0x20, repeats = Yes, order = 0, 
    callout = _UIGestureRecognizerUpdateObserver (0x10d32b473), context = &lt;CFRunLoopObserver context 0x600000b4c070&gt;}",
    
    "&lt;CFRunLoopObserver 0x600001144500 [0x10aa86b68]&gt;{valid = Yes, activities = 0xa0, repeats = Yes, order = 1999000, 
    callout = _beforeCACommitHandler (0x10d788dfc), context = &lt;CFRunLoopObserver context 0x7fbbc5001b30&gt;}",
    
    "&lt;CFRunLoopObserver 0x600001145400 [0x10aa86b68]&gt;{valid = Yes, activities = 0xa0, repeats = Yes, order = 2000000, 
    callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv (0x10f1876ae), context = &lt;CFRunLoopObserver context 0x0&gt;}",
    
    "&lt;CFRunLoopObserver 0x6000011445a0 [0x10aa86b68]&gt;{valid = Yes, activities = 0xa0, repeats = Yes, order = 2001000, 
    callout = _afterCACommitHandler (0x10d788e75), context = &lt;CFRunLoopObserver context 0x7fbbc5001b30&gt;}",
    
    "&lt;CFRunLoopObserver 0x6000011441e0 [0x10aa86b68]&gt;{valid = Yes, activities = 0xa0, repeats = Yes, order = 2147483647, 
    callout = _wrapRunLoopWithAutoreleasePoolHandler (0x10d7591b1), context = &lt;CFArray 0x600002e54ed0 [0x10aa86b68]&gt;{type = mutable-small, count = 1, values = (\n\t0 : &lt;0x7fbbc4002058&gt;\n)}}"
)

</code></pre></div></div>

<p>其中 _UIGestureRecognizerUpdateObserver 为监听手势更新事件，另外 CoreAnimation 相关的有 3 个：</p>

<ul>
  <li>_beforeCACommitHandler</li>
  <li>_ZN2CA11Transaction17observer</li>
  <li>_afterCACommitHandler</li>
</ul>

<p>还有 2 个和 AutoReleasePool 相关：</p>

<ul>
  <li>_wrapRunLoopWithAutoreleasePoolHandler order = -2147483647,</li>
  <li>_wrapRunLoopWithAutoreleasePoolHandler order = 2147483647,</li>
</ul>

<p>第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用<code class="highlighter-rouge">_objc_autoreleasePoolPush()</code>创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。</p>

<p>第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用<code class="highlighter-rouge">_objc_autoreleasePoolPop()</code>和<code class="highlighter-rouge">_objc_autoreleasePoolPush()</code>释放旧的池并创建新池； Exit (即将退出 Loop ) 时调用<code class="highlighter-rouge">_objc_autoreleasePoolPop()</code>来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。</p>

<p>在创建子线程时，在线程的入口函数中，我们就需要自己加上自动释放池代码：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- (void)threadEntryPoint {
	@autoreleasepool {
	    // Do thread work here.
    }
}
</code></pre></div></div>

<h2 id="六runloop-的内部逻辑">六、RunLoop 的内部逻辑</h2>

<p>如果对上面的内容有了初步了解，那应该掌握了 RunLoop 内部大概的组成结构，这个时候可以来看看 RunLoop 其内部运行的逻辑。</p>

<p>这里羞耻的直接贴上 YY 大神简化后的逻辑，相信很多人已经看过，不过还是贴出来让更多人知道（文末有参考链接），对更多细节感兴趣的同学可以在<a href="https://opensource.apple.com/source/CF/CF-855.17/">源码</a>中查看。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/// 用DefaultMode启动
void CFRunLoopRun(void) {
    CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);
}
 
/// 用指定的Mode启动，允许设置RunLoop超时时间
int CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean stopAfterHandle) {
    return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);
}
 
/// RunLoop的实现
int CFRunLoopRunSpecific(runloop, modeName, seconds, stopAfterHandle) {
    
    /// 首先根据modeName找到对应mode
    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop, modeName, false);
    /// 如果mode里没有source/timer/observer, 直接返回。
    if (__CFRunLoopModeIsEmpty(currentMode)) return;
    
    /// 1. 通知 Observers: RunLoop 即将进入 loop。
    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);
    
    /// 内部函数，进入loop
    __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) {
        
        Boolean sourceHandledThisLoop = NO;
        int retVal = 0;
        do {
 
            /// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。
            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);
            /// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。
            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);
            /// 执行被加入的block
            __CFRunLoopDoBlocks(runloop, currentMode);
            
            /// 4. RunLoop 触发 Source0 (非port) 回调。
            sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle);
            /// 执行被加入的block
            __CFRunLoopDoBlocks(runloop, currentMode);
 
            /// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。
            if (__Source0DidDispatchPortLastTime) {
                Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg)
                if (hasMsg) goto handle_msg;
            }
            
            /// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。
            if (!sourceHandledThisLoop) {
                __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);
            }
            
            /// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。
            /// • 一个基于 port 的Source 的事件。
            /// • 一个 Timer 到时间了
            /// • RunLoop 自身的超时时间到了
            /// • 被其他什么调用者手动唤醒
            __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort) {
                mach_msg(msg, MACH_RCV_MSG, port); // thread wait for receive msg
            }
 
            /// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。
            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);
            
            /// 收到消息，处理消息。
            handle_msg:
 
            /// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。
            if (msg_is_timer) {
                __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())
            } 
 
            /// 9.2 如果有dispatch到main_queue的block，执行block。
            else if (msg_is_dispatch) {
                __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);
            } 
 
            /// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件
            else {
                CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);
                sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg);
                if (sourceHandledThisLoop) {
                    mach_msg(reply, MACH_SEND_MSG, reply);
                }
            }
            
            /// 执行加入到Loop的block
            __CFRunLoopDoBlocks(runloop, currentMode);
            
 
            if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) {
                /// 进入loop时参数说处理完事件就返回。
                retVal = kCFRunLoopRunHandledSource;
            } else if (timeout) {
                /// 超出传入参数标记的超时时间了
                retVal = kCFRunLoopRunTimedOut;
            } else if (__CFRunLoopIsStopped(runloop)) {
                /// 被外部调用者强制停止了
                retVal = kCFRunLoopRunStopped;
            } else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) {
                /// source/timer/observer一个都没有了
                retVal = kCFRunLoopRunFinished;
            }
            
            /// 如果没超时，mode里没空，loop也没被停止，那继续loop。
        } while (retVal == 0);
    }
    
    /// 10. 通知 Observers: RunLoop 即将退出。
    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);
</code></pre></div></div>

<h2 id="总结">总结</h2>

<p>RunLoop 有一部分涉及到内核部分的知识，已经把这部分列入学习计划当中。如果还有一些 RunLoop 相关知识没有谈到的，可以查看文末参考文章，都是出自大神之手。</p>

<h2 id="参考">参考</h2>

<ul>
  <li><a href="https://blog.ibireme.com/2015/05/18/runloop/">深入理解RunLoop</a></li>
  <li><a href="http://yulingtianxia.com/blog/2017/09/17/Threading-Programming-Guide-2/#%E9%85%8D%E7%BD%AE-Run-Loop-Source">Threading Programming Guide(2)</a></li>
</ul>

  </section>
</article>

<section class="read-more">
   
   
   <div class="read-more-item">
       <span class="read-more-item-dim">最近的文章</span>
       <h2 class="post-list__post-title post-title"><a href="/2019/05/ARC/" title="link to 理解 ARC 实现原理">理解 ARC 实现原理</a></h2>
       <p class="excerpt">ARC 是 iOS 中管理引用计数的技术，帮助 iOS 实现垃圾自动回收，具体实现的原理是由编译器进行管理的，同时运行时库协助编译器辅助完成。主要涉及到 Clang （LLVM 编译器） 和 objc4 运行时库。本文主要内容由修饰符 __strong 、 __weak 、 __autorelease 拓展开，分别延伸出引用计数、弱引用表、自动释放池等实现原理。在阅读本文之前，你可以看看下面几个问题：      在 ARC 下如何存储引用计数？        如[NSDictionary ...&hellip;</p>
       <div class="post-list__meta"><time datetime="2019-05-20 10:40:11 +0800" class="post-list__meta--date date">2019-05-20</time> &#8226; <span class="post-list__meta--tags tags"></span><a class="btn-border-small" href=/2019/05/ARC/>继续阅读</a></div>
   </div>
   
   
   
   
   <div class="read-more-item">
       <span class="read-more-item-dim">更早的文章</span>
       <h2 class="post-list__post-title post-title"><a href="/2019/03/DesignPatterns/" title="link to 学习并理解 23 种设计模式">学习并理解 23 种设计模式</a></h2>
       <p class="excerpt">  设计模式 Design Pattern 是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结，使用设计模式是为了可重用代码、让代码更容易被他人理解并且保证代码可靠性。。在《设计模式：可复用面向对象软件的基础》一书中所介绍的 23 种经典设计模式，不过设计模式并不仅仅只有这 23 种，随着软件开发行业的发展，越来越多的新模式不断诞生并得以应用。有经验的开发者在学习设计模式可以和过往的经验互相印证，更容易理解这些设计模式。设计模式一般包含模式名称、问题、目的、解决方案、效果等...&hellip;</p>
       <div class="post-list__meta"><time datetime="2019-03-03 10:40:11 +0800" class="post-list__meta--date date">2019-03-03</time> &#8226; <span class="post-list__meta--tags tags"></span><a class="btn-border-small" href=/2019/03/DesignPatterns/>继续阅读</a></div>
   </div>
   
</section>

<section class="post-comments">
   
    <div id="gitalk-container"></div>
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

    <script type="text/javascript">
      var gitalk = new Gitalk({
        clientID: 'a7e3bcc8c313f6fcf2cf',
        clientSecret: '1d7f990ff0250384dea6b037ce7d6e455d84d472',
        repo: 'xietao3.github.io',
        owner: 'xietao3',
        admin: ['xietao3'],
        id: 'BlogComment',
        distractionFreeMode: true
      });
      gitalk.render('gitalk-container');

    </script>

  



  
  
  
</section>


            <section class="footer">
    <footer>
    	<span class="footer__copyright">本站点采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议</a></span>
        <span class="footer__copyright">本站由 <a href="http://xietao3.com/about">xietao3</a> 
        创建，采用 <a href="https://github.com/onevcat/vno-jekyll">Vno - Jekyll</a> 作为主题，您可以在 GitHub 找到<a href="https://github.com/onevcat/OneV-s-Den">本站源码</a> - &copy; 2016</span>
    </footer>
</section>

        </div>
    </div>
    
    <script type="text/javascript" src="//code.jquery.com/jquery-1.11.3.min.js"></script>

<script type="text/javascript" src="/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<script type="text/javascript" src="/js/main.js"></script>



    
  </body>

</html>
